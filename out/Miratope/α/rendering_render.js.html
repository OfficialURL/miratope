<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>rendering/render.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AvlNode.html">AvlNode</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rotateRight">rotateRight</a></li></ul></li><li><a href="AvlTree.html">AvlTree</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AvlTree.html#.maxValueNode">maxValueNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#.minValueNode">minValueNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#_compare">_compare</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#_delete">_delete</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#_get">_get</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#_insert">_insert</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#contains">contains</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#getNode">getNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#insert">insert</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#next">next</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#prev">prev</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#size">size</a></li></ul></li><li><a href="Caret.html">Caret</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Caret.html#advance">advance</a></li><li data-type='method' style='display: none;'><a href="Caret.html#getChar">getChar</a></li><li data-type='method' style='display: none;'><a href="Caret.html#increment">increment</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readNumber">readNumber</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readUntil">readUntil</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readWord">readWord</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToString">skipToString</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type='method' style='display: none;'><a href="Caret.html#throwError">throwError</a></li></ul></li><li><a href="ConstructionNode.html">ConstructionNode</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ConstructionNode.html#_mergeChildren">_mergeChildren</a></li><li data-type='method' style='display: none;'><a href="ConstructionNode.html#_setGenders">_setGenders</a></li><li data-type='method' style='display: none;'><a href="ConstructionNode.html#getName">getName</a></li><li data-type='method' style='display: none;'><a href="ConstructionNode.html#setGenders">setGenders</a></li></ul></li><li><a href="Polytope.html">Polytope</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Polytope.html#._checkCommonElements">_checkCommonElements</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#._divide">_divide</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#._getIndexOfPrismProduct">_getIndexOfPrismProduct</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#._minimize">_minimize</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#._OFFReaderOnload">_OFFReaderOnload</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#._prismProduct">_prismProduct</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#._product">_product</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.dyad">dyad</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.nullitope">nullitope</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.point">point</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.prismProduct">prismProduct</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.verfLength">verfLength</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#circumradius">circumradius</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#getName">getName</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#move">move</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#moveNeg">moveNeg</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#renderTo">renderTo</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#saveAsOFF">saveAsOFF</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#scale">scale</a></li></ul></li><li><a href="PolytopeC.html">PolytopeC</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#recenter">recenter</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li></ul></li><li><a href="SweeplineEdge.html">SweeplineEdge</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type='method' style='display: none;'><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="BalanceState.html">BalanceState</a></li><li><a href="ConstructionNodeType.html">ConstructionNodeType</a></li><li><a href="Translation.html">Translation</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type='method' style='display: none;'><a href="Translation.html#.elementName">elementName</a></li><li data-type='method' style='display: none;'><a href="Translation.html#.greekPrefix">greekPrefix</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#getBalanceState">getBalanceState</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">rendering/render.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** Renders a polytope into a scene.
 * Implements the Bentley-Ottmann algorithm
 * as well as a simplification algorithm
 * to triangulate general polygons.
 * @summary Renders a polytope into a scene.
 * @todo Guarantee that all edge cases work properly.
 * @see {@link http://geomalgorithms.com/a09-_intersect-3.html|[1] Dan Sunday. Intersections for a Set of Segments. 2012.}
 */
Polytope.prototype.renderTo = function(scene) {
	var P = this.toPolytopeC().recenter();

	function debug() {
		var x = 0;
		console.log(E.value.coordinates[window.index0].toString());
		console.log(SL.toString());
	};

	//SL is sorted by the height of the edges' intersections with the sweepline.
	//If these are equal, the lines are sorted by slope.
	//If both are equal, the lines are consistently ordered by their IDs (unique, immutable identifiers).
	function SLSort(x, y){
		//This is the only case where the function should return 0:
		if(x.leftVertex === y.leftVertex &amp;&amp; x.rightVertex() === y.rightVertex())
			return 0;

		var a = x.leftVertex.value,
		b = x.rightVertex().value,
		c = y.leftVertex.value,
		d = y.rightVertex().value,
		k = E.value.coordinates[window.index0], slopeMod;

		//Calculates where in the segments the intersection with the sweepline lies.
		var lambda0 = (k - b.coordinates[window.index0])/(a.coordinates[window.index0] - b.coordinates[window.index0]);
		var lambda1 = (k - d.coordinates[window.index0])/(c.coordinates[window.index0] - d.coordinates[window.index0]);

		//The height difference between the intersections.
		var res = (a.coordinates[window.index1] * lambda0 + b.coordinates[window.index1] * (1 - lambda0)) - (c.coordinates[window.index1] * lambda1 + d.coordinates[window.index1] * (1 - lambda1));

		//If the intersections are so similar, we also need to consider the possibility
		//that the edges actually have a common endpoint.
		if (Math.abs(res) &lt; epsilon) {
			//If the first edge starts at a point, and the second ends at that point, the former gets sorted after the latter.
			if(lambda0 > 1 - epsilon &amp;&amp; lambda1 &lt; epsilon)
				return 1;
			//And viceversa.
			if(lambda0 &lt; epsilon &amp;&amp; lambda1 > 1 - epsilon)
				return -1;

			//If both edges start at the same point, sort by increasing slope.
			if(lambda0 > 1 - epsilon)
				slopeMod = 1;
			//If both edges end at the same point, sort by decreasing slope.
			else if(lambda0 &lt; epsilon)
				slopeMod = -1;
			//The edges are just really close, so compare them normally.
			else
				return res;

			//The difference between the slopes.
			res = slopeMod * (Math.atan(x.slope) - Math.atan(y.slope));

			//If both lines are the same, might as well compare using indices.
			if(Math.abs(res) &lt; epsilon)
				return x.id - y.id;
		}
		return res;
	};

	var j, k;

	//For each face:
	faceLoop:
	for(var i = 0; i &lt; P.elementList[2].length; i++){
		//Let's not even bother with digons and monogons.
		if(P.elementList[2][i].length &lt; 3)
			continue faceLoop;
	/*	if(P.elementList[2][i].length === 3) {
			//All triangles are convex, so cut to the chase and render it directly.
		} */

		//Enumerates the vertices in order.
		var cycle = P.faceToVertices(i);

		//Makes a doubly-linked list vertexDLL for the polygon's vertices and the new vertices created.
		//node0 is always the "next" vertex.
		Polytope.vertexDLL = [new LinkedListNode(P.elementList[0][cycle[0]])]; var vertexDLL = Polytope.vertexDLL;
		for(j = 0; j &lt; cycle.length - 1; j++) {
			vertexDLL[j + 1] = new LinkedListNode(P.elementList[0][cycle[j + 1]]);
			vertexDLL[j].linkToNext(vertexDLL[j + 1]);
		}
		vertexDLL[vertexDLL.length - 1].linkToNext(vertexDLL[0]);

		//Tries to find two non-equal points. If all points are the same, doesn't render the face.
		var a = 1;
		while(Point.equal(vertexDLL[0].value, vertexDLL[a].value))
			if(++a >= vertexDLL.length)
				continue faceLoop;

		//Tries to find three non-collinear points. If all points are collinear, doesn't render the face.
		var b = (a === 1 ? 2 : 1);
		while(Space.collinear(vertexDLL[0].value, vertexDLL[a].value, vertexDLL[b].value))
			if(++b >= vertexDLL.length)
				continue faceLoop;

		//Calculates the coordinates such that the projection of our three non-collinear points onto their 2D plane has the highest area.
		//Uses the shoelace formula.
		//Stores such coordinates' indices in window.index0, window.index1.
		//That way, they become global variables that can be used elsewhere.
		var maxArea = 0,
		Area,
		va = vertexDLL[a].value,
		vb = vertexDLL[b].value,
		v0 = vertexDLL[0].value;
		window.index0 = 0;
		window.index1 = 1;
		for(j = 0; j &lt; v0.dimensions(); j++) {
			for(k = j + 1; k &lt; v0.dimensions(); k++) {
				if((Area = Math.abs(
					v0.coordinates[j] * (va.coordinates[k] - vb.coordinates[k])
					+ va.coordinates[j] * (vb.coordinates[k] - v0.coordinates[k])
					+ vb.coordinates[j] * (v0.coordinates[k] - va.coordinates[k])
				))
				> maxArea) {
					window.index0 = j;
					window.index1 = k;
					maxArea = Area;
				}
			}
		}

		//Event queue for Bentley-Ottmann, stores vertices.
		//Sorts EQ by lexicographic order of the vertices (EQ is read backwards at the moment).

		Polytope.EQ = new AvlTree(Polytope._order); var EQ = Polytope.EQ;
		for(j = 0; j &lt; vertexDLL.length; j++)
			EQ.insert(vertexDLL[j]);

		//Sweep line for Bentley-Ottmann, as an object with properties leftVertex and rightVertexIndex.
		//rightVertexIndex should be 0 if leftVertex.node0.value is to the right of leftVertex.value, 1 if leftVertex.node1.value is.
		//This format is useful because an edge on the sweep line can only be cut to the right.
		//That way, we don't need to modify the SL objects after the division process: only the nodes' connections change.

		var SL = new AvlTree(SLSort), counter=0;

		//Bentley-Ottmann:
		while(!EQ.isEmpty()) {
			counter++;
			var E = EQ.findMinimum(); //The next "event" in the event queue.
			EQ.delete(E);
			if(!SL.checkSorted()) { //If the code worked perfectly, we could skip this part.
				alert("Something went wrong!");
				//return; //Uncomment if you want the code not to throw an exception.
			}

			//Runs P code on both edges adjacent to E's vertex.
			for(j = 0; j &lt;= 1; j++) {
				var edge, //E's edge in the SL format.
				ord = E.value.coordinates[window.index0] - E.getNode(j).value.coordinates[window.index0],
				pos = 0,
				node, prevNode, nextNode;

				//Vertex E is a left endpoint of the edge:
				if(ord &lt; -epsilon) {
					edge = new SweeplineEdge(E, j);
					node = SL.insert(edge);
					if(!node) {
						console.log("SL insertion failed! This isn't supposed to happen!");
						console.log("Edge searched for: " + edge.toString());
						console.log("Debug stuff:");
						debug();
					}
					prevNode = SL.prev(node);
					nextNode = SL.next(node);

					if(prevNode)
						Polytope._divide(edge, prevNode.key, vertexDLL, EQ); //Checks for an intersection with the edge below edgeE.
					if(nextNode)
						Polytope._divide(edge, nextNode.key, vertexDLL, EQ); //Checks for an intersection with the edge above edgeE.
				}
				//Vertex E is a right endpoint of the edge:
				else if (ord > epsilon) {
					edge = new SweeplineEdge(E.getNode(j), 1 - j);

					//Deletes edge from the sweep line.
					node = SL.getNode(edge);
					if(!node) {
						console.log("SL retrieval failed! This isn't supposed to happen!");
						console.log("Edge searched for: " + edge.toString());
						console.log("Debug stuff:");
						debug();
					}
					prevNode = SL.prev(node);
					nextNode = SL.next(node);

					if(prevNode &amp;&amp; nextNode)
						Polytope._divide(prevNode.key, nextNode.key, vertexDLL, EQ); //Checks for an intersection between the edges below and above edgeE.
					SL.delete(edge);
				}
				//The edge is perpendicular to the first coordinate's axis:
				//Runs only once per such an edge.
				else if(E.value.coordinates[window.index1] > E.getNode(j).value.coordinates[window.index1]) {
					edge = new SweeplineEdge(E, j);

					//I really should only check intersections with segments at the "correct height".
					node = SL.findMinimumNode();
					while(node) {
						Polytope._divide(edge, node.key, vertexDLL, EQ);
						node = SL.next(node);
					}
				}
			}
		}

		//Polygons composing a single face as ordered sets of vertices.
		var face = [];

		//Retrieves polygonal paths from edges.
		for(j = 0; j &lt; vertexDLL.length; j++) {
			if(!vertexDLL[j].traversed)
				face.push(vertexDLL[j].getCycle());
		}

		//The rest of the rendering shenanigans are handled by the Scene class.
		scene.add(face);
	}

	scene.polytopes.push(this);
};

/**
 * renderTo helper function.
 * "Cuts" two edges at the intersection point, adds the new directed edges according to the simplification algorithm.
 * @private
 * @param {SLEdge} edgeA The first edge to cut.
 * @param {SLEdge} edgeB The second edge to cut.
 */
Polytope._divide = function(edgeA, edgeB) {
	//No point in doing anything if the intersection has already been dealt with.
	//...what happens if two different vertices take the same location?
	if(edgeA.leftVertex.value === edgeB.leftVertex.value || edgeA.leftVertex.value === edgeB.rightVertex().value ||
	edgeA.rightVertex().value === edgeB.leftVertex.value || edgeA.rightVertex().value === edgeB.rightVertex().value)
		return;

	//Converts edges from the SL format to the [vertex1, vertex2] directed edge format.
	var edgeADir, edgeBDir;
	if(edgeA.rightVertexIndex === 0)
		edgeADir = [edgeA.leftVertex, edgeA.leftVertex.node0];
	else
		edgeADir = [edgeA.leftVertex.node1, edgeA.leftVertex];
	if(edgeB.rightVertexIndex === 0)
		edgeBDir = [edgeB.leftVertex, edgeB.leftVertex.node0];
	else
		edgeBDir = [edgeB.leftVertex.node1, edgeB.leftVertex];

	//No point in doing anything if the intersection is non-existent.
	var inter = Space.intersect(edgeADir[0].value, edgeADir[1].value, edgeBDir[0].value, edgeBDir[1].value);
	if(inter === null)
		return;

	//Add the intersection and a point at "infinitesimal distance" to the vertex list.
	//They don't actually have to be different in this implementation of the algorithm.
	//In fact, the algorithm (as implemented) will fail if both nodes don't reference the same point.
	var newNode1 = new LinkedListNode(inter),
	newNode2 = new LinkedListNode(inter),
	vertexDLL = Polytope.vertexDLL,
	EQ = Polytope.EQ;

	vertexDLL.push(newNode1); vertexDLL.push(newNode2);

	//Re-links the vertices.
	edgeADir[0].linkToNext(newNode1);
	newNode1.linkToNext(edgeBDir[1]);
	edgeBDir[0].linkToNext(newNode2);
	newNode2.linkToNext(edgeADir[1]);

	//Adds the edges' new IDs to the redirect table, so that they remain equal and consistent.
	edgeA.updateRedirectTable();
	edgeB.updateRedirectTable();

	EQ.insert(newNode1);
	EQ.insert(newNode2);
};


/* Orders two points lexicographically based on the coordinates on indices 0 and 1.
 * Uses the IDs of the vertices to order them consistently if their coordinates are identical.
 * @private
 * @param {number[]} The first point to order.
 * @param {number[]} The second point to order.
 * @returns {number} 1, 0 or -1 depending on whether a > b, a = b or a &lt; b.
 */
Polytope._order = function(a, b) {
	var c = a.value.coordinates[window.index0] - b.value.coordinates[window.index0];
	if(c === 0) { //DO NOT REPLACE BY Math.abs(c) &lt; epsilon
		c = a.value.coordinates[window.index1] - b.value.coordinates[window.index1];
		if(c === 0)
			return a.id - b.id;
	}
	return c;
};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Fri Oct 30 2020 12:08:45 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
