<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>importing/off.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/officialurl/miratope" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h3>Classes</h3><ul><li><a href="AvlNode.html">AvlNode</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rotateRight">rotateRight</a></li></ul></li><li><a href="AvlTree.html">AvlTree</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AvlTree.html#.getBalanceState">getBalanceState</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#contains">contains</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#getNode">getNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#insert">insert</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#size">size</a></li></ul></li><li><a href="Caret.html">Caret</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Caret.html#advance">advance</a></li><li data-type='method' style='display: none;'><a href="Caret.html#getChar">getChar</a></li><li data-type='method' style='display: none;'><a href="Caret.html#increment">increment</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readNumber">readNumber</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readUntil">readUntil</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readWord">readWord</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToString">skipToString</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type='method' style='display: none;'><a href="Caret.html#throwError">throwError</a></li></ul></li><li><a href="ConstructionNode.html">ConstructionNode</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ConstructionNode.html#getName">getName</a></li><li data-type='method' style='display: none;'><a href="ConstructionNode.html#setGenders">setGenders</a></li></ul></li><li><a href="Point.html">Point</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Point.html#.product">product</a></li><li data-type='method' style='display: none;'><a href="Point.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="Point.html#dimensions">dimensions</a></li><li data-type='method' style='display: none;'><a href="Point.html#scale">scale</a></li></ul></li><li><a href="Polytope.html">Polytope</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Polytope.html#._determinant">_determinant</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#._GGBReaderOnload">_GGBReaderOnload</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.adjacentEls">adjacentEls</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.cdToMatrix">cdToMatrix</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.dyad">dyad</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.nullitope">nullitope</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.point">point</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.prismProduct">prismProduct</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.regularPolygon">regularPolygon</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.semiregularPolygon">semiregularPolygon</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.spaceShape">spaceShape</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#.verfLength">verfLength</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#circumradius">circumradius</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#extrudeToPyramid">extrudeToPyramid</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#getName">getName</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#move">move</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#moveNeg">moveNeg</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#polytopeToGraph">polytopeToGraph</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#renderTo">renderTo</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#saveAsOFF">saveAsOFF</a></li><li data-type='method' style='display: none;'><a href="Polytope.html#scale">scale</a></li></ul></li><li><a href="PolytopeC.html">PolytopeC</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#recenter">recenter</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li></ul></li><li><a href="SweeplineEdge.html">SweeplineEdge</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type='method' style='display: none;'><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="BalanceState.html">BalanceState</a></li><li><a href="ConstructionNodeType.html">ConstructionNodeType</a></li><li><a href="Space.html">Space</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Space.html#.distance">distance</a></li><li data-type='method' style='display: none;'><a href="Space.html#.distanceSq">distanceSq</a></li><li data-type='method' style='display: none;'><a href="Space.html#.intersect">intersect</a></li></ul></li><li><a href="Translation.html">Translation</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type='method' style='display: none;'><a href="Translation.html#.elementName">elementName</a></li><li data-type='method' style='display: none;'><a href="Translation.html#.greekPrefix">greekPrefix</a></li></ul></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-dependencies.html">How to update Miratope's dependencies?</a></li><li><a href="tutorial-translation_.html">How to translate Miratope?</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">importing/off.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

//The part of the Polytope class for reading and writing to OFF files.

/**
 * Helper function for {@link Polytope.openFile}.
 * Is called when an OFF file is loaded.
 * @private
 * @param {Object} e The event handler.
 */
Polytope._OFFReaderOnload = function(e) {
	var caret = new Caret(e.target.result), //Caret for reading the OFF file.
	component, //A component of the polytope.
	dimensions = caret.readNumber(), //The number of dimensions of the OFF file's polytope.
	el, //An element of the polytope.
	elCount = 0, //The number of facets in an element of the polytope.
	edgeList = [], //A dictionary mapping hashes of pairs of integers to edge indices.
	elementCount = [], //The amount of vertices, edges, faces... elementCount[1] goes unused except for the special case of 2D components.
	elementList = [[]], //The elements of the described polytope.
	face, //A face of the polytope.
	facets, //The list of facets of the polytope.
	i, j, x, y, t; //Temporary variables used in for loops.

	//The file just starts with OFF.
	if(isNaN(dimensions))
		dimensions = 3;

	//Checks that the word OFF is the next thing on the file.
	if(caret.readWord() !== "OFF")
		caret.throwError("invalidFile");

	//Nullitope
	if(dimensions === -1) {
		P = Polytope.nullitope();
		return;
	}

	//Point
	if(dimensions === 0) {
		P = Polytope.point();
		return;
	}

	//Reads vertex amount.
	if(dimensions >= 1) {
		elementCount.push(caret.readNumber());
		elementList.push([]);
	}

	//Reads face and edge amounts.
	if(dimensions >= 3) {
		elementCount.push(null, caret.readNumber());
		caret.readWord(); //We can't actually care about the edge amount, since Stella itself ignores it.
		elementList.push([], []);
	}

	//Reads component amount in the special 2OFF case.
	else if(dimensions === 2) {
		elementCount.push(null, caret.readNumber());
		elementList.push([]);
	}

	//Reads higher element amounts.
	for(i = 3; i &lt; dimensions; i++) {
		elementCount.push(caret.readNumber());
		elementList.push([]);
	}

	//Adds vertices.
	for(i = 0; i &lt; elementCount[0]; i++) {
		el = [];
		for(j = 0; j &lt; dimensions; j++)
			el.push(caret.readNumber());
		elementList[0].push(new Point(el));
	}

	if(dimensions >= 2) {
		//Adds faces and edges (or compounds in the special case).
		for(i = 0; i &lt; elementCount[2]; i++) {
			el = [];
			face = [];
			elCount = caret.readNumber();

			//Retrieves vertices.
			for(j = 0; j &lt; elCount; j++)
				el.push(caret.readNumber());

			//Creates edges.
			for(j = 0; j &lt; elCount - 1; j++) {
				//Orders the edge's vertices.
				x = el[j];
				y = el[j + 1];
				if(x &lt; y) {
					t = x;
					x = y;
					y = t;
				}
				t = (x + y + 1) * (x + y) / 2 + y; //Cantor pairing function.
				if(edgeList[t] === undefined) {
					edgeList[t] = elementList[1].length;
					elementList[1].push([x, y]);
				}
				face.push(edgeList[t]);
			}
			//Last edge.
			x = el[0];
			y = el[el.length - 1];
			if(x &lt; y) {
				t = x;
				x = y;
				y = t;
			}
			t = (x + y + 1) * (x + y) / 2 + y; //Cantor pairing function.
			if(edgeList[t] === undefined) {
				edgeList[t] = elementList[1].length;
				elementList[1].push([x, y]);
			}
			face.push(edgeList[t]);

			elementList[2].push(face);
		}
	}

	//Adds higher-dimensional elements.
	for(i = 3; i &lt; dimensions; i++) {
		for(j = 0; j &lt; elementCount[i]; j++) {
			el = [];
			elCount = caret.readNumber();
			for(t = 0; t &lt; elCount; t++)
				el.push(caret.readNumber());
			elementList[i].push(el);
		}
	}

	//Gets components. The 1D case is trivial.
	if(dimensions === 1) {
		elementList[1].push([]);
		for(i = 0; i &lt; elementCount[0]; i++)
			elementList[1][0].push(i);
	}

	//Gets components in higher dimensions, except in 2D, where they've already been retrieved.
	else if(dimensions >= 3) {
		//Graph of incidences between facets.
		var graph = [];
		facets = elementList[elementList.length - 2];
		for(i = 0; i &lt; facets.length; i++)
			graph.push(new GraphNode(i));

		//Calculates incidences.
		for(i = 0; i &lt; facets.length; i++)
			for(j = i + 1; j &lt; facets.length; j++)
				if(Polytope._checkCommonElements(facets[i], facets[j]))
					graph[i].connectTo(graph[j]);

		//Gets components.
		for(i = 0; i &lt; facets.length; i++) {
			component = graph[i].getComponent();
			if(component)
				elementList[elementList.length - 1].push(component);
		}
	}

	P = new PolytopeC(
		elementList,
		new ConstructionNode(
			ConstructionNodeType.Name,
			Polytope.fileName
		)
	);
};

/**
 * Helper function for {@link Polytope.openFile},
 * and more specifically for {@link Polytope._OFFReaderOnload}.
 * Checks whether two arrays have a common element using a dictionary.
 * @private
 * @param {number[]} a The first array to check.
 * @param {number[]} b The second array to check.
 * @returns {boolean} Whether the arrays have a common element or not.
 */
Polytope._checkCommonElements = function(a, b) {
	var vals = {}, i;
	vals[a[i]] = true;

	for(i = 1; i &lt; a.length; i++) {
		if(vals[a[i]])
			return true;
		vals[a[i]] = true;
	}

	for(i = 0; i &lt; b.length - 1; i++) {
		if(vals[b[i]])
			return true;
		vals[b[i]] = true;
	}

	return !!vals[b[i]];
};

/**
 * Saves the current polytope as an OFF file.
 * @param {Object=} options The file saving options.
 * @param {boolean=} options.comments Whether the file should contain comments
 * specifying separations between element types.
 */
Polytope.prototype.saveAsOFF = function(options = {}) {
	var P = this.toPolytopeC(),
	i, j, coord, vertices;

	if(P.spaceDimensions > P.dimensions) {
		//Maybe automatically project the polytope?
		alert("The OFF format does not support polytopes in spaces with more dimensions than themselves.");
		return;
	}

	//The contexts of the OFF file, as an array of plaintext strings.
	var data = [],
  //I should be using precise counts here.
	pluralAndUppercase = {count: 1000, uppercase: true},
  comments = options.comments;

	//Writes the element counts, and optionally, leaves a comment listing their names in order.
	switch(P.dimensions) {
		case 0: //LOL
			data.push("0OFF");
			break;
		case 1: //Also LOL
			data.push("1OFF\n");
			if(comments)
				data.push("# ", Translation.elementName(0, pluralAndUppercase), "\n");
			data.push(P.elementList[0].length, "\n");
			break;
		case 2:
			data.push("2OFF\n");
			if(comments)
				data.push("# ", Translation.elementName(0, pluralAndUppercase), ", ", Translation.get("misc/component", pluralAndUppercase), "\n");
			data.push(P.elementList[0].length, " ", P.elementList[2].length, "\n");
			break;
		case 3:
			data.push("OFF\n"); //For compatibility with Stella.
			if(comments)
				data.push("# ", Translation.elementName(0, pluralAndUppercase), ", ", Translation.elementName(2, pluralAndUppercase), ", ", Translation.elementName(1, pluralAndUppercase), "\n");
			data.push(P.elementList[0].length, " ", P.elementList[2].length, " ", P.elementList[1].length, "\n");
			break;
		default:
			data.push(P.dimensions, "OFF\n");
			if(comments) {
				data.push("# ", Translation.elementName(0, pluralAndUppercase), ", ", Translation.elementName(2, pluralAndUppercase), ", ", Translation.elementName(1, pluralAndUppercase));
				for(i = 3; i &lt; P.dimensions; i++)
					data.push(", ", Translation.elementName(i, pluralAndUppercase));
				data.push("\n");
			}
			data.push(P.elementList[0].length, " ", P.elementList[2].length, " ", P.elementList[1].length, " ");
			for(i = 3; i &lt; P.dimensions - 1; i++)
				data.push(P.elementList[i].length, " ");
			data.push(P.elementList[P.dimensions - 1].length, "\n");
	}

	//Adds vertices. Fills in zeros if spaceDimensions &lt; dimensions.
	if(comments)
		data.push("\n# ", Translation.elementName(0, pluralAndUppercase), "\n");

	for(i = 0; i &lt; P.elementList[0].length; i++) {
		for(j = 0; j &lt; P.dimensions - 1; j++) {
			coord = P.elementList[0][i].coordinates[j];
			if(coord === undefined)
				data.push("0 ");
			else
				data.push(coord, " ");
		}
		coord = P.elementList[0][i].coordinates[P.dimensions - 1];
		if(coord === undefined)
			data.push("0\n");
		else
			data.push(coord, "\n");
	}

	//Adds faces, or copmonents for compound polygons.
	if(P.dimensions >= 2) {
		if(comments) {
			if(P.dimensions === 2)
				data.push("\n# ", Translation.get("misc/component", pluralAndUppercase), "\n");
			else
				data.push("\n# ", Translation.elementName(2, pluralAndUppercase), "\n");
		}
		for(i = 0; i &lt; P.elementList[2].length; i++) {
			vertices = P.faceToVertices(i);
			data.push(P.elementList[2][i].length);
			for(j = 0; j &lt; P.elementList[2][i].length; j++)
				data.push(" ", vertices[j]);
			data.push("\n");
		}
	}

	//Adds the rest of the elements.
	for(var d = 3; d &lt; P.dimensions; d++) {
		if(comments)
			data.push("\n# ", Translation.elementName(d, pluralAndUppercase), "\n");
		for(i = 0; i &lt; P.elementList[d].length; i++) {
			data.push(P.elementList[d][i].length);
			for(j = 0; j &lt; P.elementList[d][i].length; j++)
				data.push(" ", P.elementList[d][i][j]);
			data.push("\n");
		}
	}

	Polytope.fileName = Translation.firstToUpper(P.getName()) + ".off";
	Polytope._saveBlob(new Blob(data, {type:"text/plain"}));
};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Sat Dec 19 2020 13:43:01 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
