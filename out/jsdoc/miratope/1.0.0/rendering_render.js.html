<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>rendering/render.js - Documentation</title><script src="scripts/prettify/prettify.js"></script><script src="scripts/prettify/lang-css.js"></script><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><link type="text/css" rel="stylesheet" href="styles/prettify.css"><link type="text/css" rel="stylesheet" href="styles/jsdoc.css"><script src="scripts/nav.js" defer="defer"></script><meta name="viewport" content="width=device-width,initial-scale=1"></head><body><input type="checkbox" id="nav-trigger" class="nav-trigger"> <label for="nav-trigger" class="navicon-button x"><div class="navicon"></div></label> <label for="nav-trigger" class="overlay"></label><nav><input type="text" id="nav-search" placeholder="Search"><h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/officialurl/miratope" target="_blank" class="menu-item" id="repository">Github repo</a></h2><h3>Classes</h3><ul><li><a href="AvlNode.html">AvlNode</a><ul class="methods"><li data-type="method" style="display:none"><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateRight">rotateRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateRight">rotateRight</a></li></ul></li><li></li><li><a href="AvlTree.html">AvlTree</a><ul class="methods"><li data-type="method" style="display:none"><a href="AvlTree.html#.getBalanceState">getBalanceState</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#.getBalanceState">getBalanceState</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#contains">contains</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#contains">contains</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#delete">delete</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#delete">delete</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#getNode">getNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#getNode">getNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#insert">insert</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#insert">insert</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#size">size</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#size">size</a></li></ul></li><li></li><li><a href="Caret.html">Caret</a><ul class="methods"><li data-type="method" style="display:none"><a href="Caret.html#advance">advance</a></li><li data-type="method" style="display:none"><a href="Caret.html#advance">advance</a></li><li data-type="method" style="display:none"><a href="Caret.html#getChar">getChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#getChar">getChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#increment">increment</a></li><li data-type="method" style="display:none"><a href="Caret.html#increment">increment</a></li><li data-type="method" style="display:none"><a href="Caret.html#readNumber">readNumber</a></li><li data-type="method" style="display:none"><a href="Caret.html#readNumber">readNumber</a></li><li data-type="method" style="display:none"><a href="Caret.html#readUntil">readUntil</a></li><li data-type="method" style="display:none"><a href="Caret.html#readUntil">readUntil</a></li><li data-type="method" style="display:none"><a href="Caret.html#readWord">readWord</a></li><li data-type="method" style="display:none"><a href="Caret.html#readWord">readWord</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToString">skipToString</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToString">skipToString</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type="method" style="display:none"><a href="Caret.html#throwError">throwError</a></li><li data-type="method" style="display:none"><a href="Caret.html#throwError">throwError</a></li></ul></li><li></li><li><a href="Point.html">Point</a><ul class="methods"><li data-type="method" style="display:none"><a href="Point.html#.padLeft">padLeft</a></li><li data-type="method" style="display:none"><a href="Point.html#.padLeft">padLeft</a></li><li data-type="method" style="display:none"><a href="Point.html#.padRight">padRight</a></li><li data-type="method" style="display:none"><a href="Point.html#.padRight">padRight</a></li><li data-type="method" style="display:none"><a href="Point.html#.product">product</a></li><li data-type="method" style="display:none"><a href="Point.html#.product">product</a></li><li data-type="method" style="display:none"><a href="Point.html#add">add</a></li><li data-type="method" style="display:none"><a href="Point.html#add">add</a></li><li data-type="method" style="display:none"><a href="Point.html#addCoordinate">addCoordinate</a></li><li data-type="method" style="display:none"><a href="Point.html#addCoordinate">addCoordinate</a></li><li data-type="method" style="display:none"><a href="Point.html#clone">clone</a></li><li data-type="method" style="display:none"><a href="Point.html#clone">clone</a></li><li data-type="method" style="display:none"><a href="Point.html#dimensions">dimensions</a></li><li data-type="method" style="display:none"><a href="Point.html#dimensions">dimensions</a></li><li data-type="method" style="display:none"><a href="Point.html#project">project</a></li><li data-type="method" style="display:none"><a href="Point.html#project">project</a></li><li data-type="method" style="display:none"><a href="Point.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="Point.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="Point.html#subtract">subtract</a></li><li data-type="method" style="display:none"><a href="Point.html#subtract">subtract</a></li></ul></li><li></li><li><a href="PolytopeC.html">PolytopeC</a><ul class="methods"><li data-type="method" style="display:none"><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#recenter">recenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#recenter">recenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li></ul></li><li></li><li><a href="Scene.html">Scene</a><ul class="methods"><li data-type="method" style="display:none"><a href="Scene.html#add">add</a></li><li data-type="method" style="display:none"><a href="Scene.html#add">add</a></li></ul></li><li></li><li><a href="SweeplineEdge.html">SweeplineEdge</a><ul class="methods"><li data-type="method" style="display:none"><a href="SweeplineEdge.html#getId">getId</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#getId">getId</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li></ul></li><li></li></ul><h3>Namespaces</h3><ul><li><a href="BalanceState.html">BalanceState</a></li><li></li><li><a href="ConstructionNodeType.html">ConstructionNodeType</a></li><li></li><li><a href="Space.html">Space</a><ul class="methods"><li data-type="method" style="display:none"><a href="Space.html#.area">area</a></li><li data-type="method" style="display:none"><a href="Space.html#.area">area</a></li><li data-type="method" style="display:none"><a href="Space.html#.distance">distance</a></li><li data-type="method" style="display:none"><a href="Space.html#.distance">distance</a></li><li data-type="method" style="display:none"><a href="Space.html#.distanceSq">distanceSq</a></li><li data-type="method" style="display:none"><a href="Space.html#.distanceSq">distanceSq</a></li><li data-type="method" style="display:none"><a href="Space.html#.intersect">intersect</a></li><li data-type="method" style="display:none"><a href="Space.html#.intersect">intersect</a></li><li data-type="method" style="display:none"><a href="Space.html#.sameSlope">sameSlope</a></li><li data-type="method" style="display:none"><a href="Space.html#.sameSlope">sameSlope</a></li></ul></li><li></li><li><a href="Translation.html">Translation</a><ul class="methods"><li data-type="method" style="display:none"><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type="method" style="display:none"><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type="method" style="display:none"><a href="Translation.html#.elementName">elementName</a></li><li data-type="method" style="display:none"><a href="Translation.html#.elementName">elementName</a></li><li data-type="method" style="display:none"><a href="Translation.html#.greekPrefix">greekPrefix</a></li><li data-type="method" style="display:none"><a href="Translation.html#.greekPrefix">greekPrefix</a></li></ul></li><li></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-dependencies.html">How to update Miratope's dependencies?</a></li><li><a href="tutorial-translation_.html">How to translate Miratope?</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BalanceState%255Bundefined%255D">BalanceState[undefined]</a></li><li><a href="global.html#CNType%255Bundefined%255D">CNType[undefined]</a></li></ul></nav><div id="main"><h1 class="page-title">rendering/render.js</h1><section><article><pre class="prettyprint source linenums"><code>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Render = void 0;
const point_1 = require("../geometry/point");
const space_1 = require("../geometry/space");
const polytopeTypes_1 = require("../polytopes/polytopeTypes");
const linkedListNode_1 = require("../data structures/linkedListNode");
const sweeplineEdge_1 = require("../data structures/sweeplineEdge");
const avl_tree_1 = require("../data structures/avl-tree");
const global_1 = require("../global");
class Render {
    /** Renders a polytope into a scene.
     * Implements the Bentley-Ottmann algorithm
     * as well as a simplification algorithm
     * to triangulate general polygons.
     * @summary Renders a polytope into a scene.
     * @todo Guarantee that all edge cases work properly (zero length edges,
     * collinear edges, concurrent edges, etc.)
     * @see {@link http://geomalgorithms.com/a09-_intersect-3.html|Dan Sunday. Intersections for a Set of Segments. 2012.}
     */
    static to(P_, scene) {
        const SL = new avl_tree_1.AvlTree(SLSort);
        function debug() {
            console.log(Render.Event.value.coordinates[global_1.Global.index0].toString());
            console.log(SL.toString());
        }
        //SL is sorted by the height of the edges' intersections with the sweepline.
        //If these are equal, the lines are sorted by slope.
        //If both are equal, the lines are consistently ordered by their IDs
        //(unique, immutable identifiers).
        function SLSort(x, y) {
            //This is the only case where the function should return 0:
            if (x.leftVertex === y.leftVertex &amp;&amp; x.rightVertex() === y.rightVertex())
                return 0;
            const a = x.leftVertex.value, b = x.rightVertex().value, c = y.leftVertex.value, d = y.rightVertex().value, k = Render.Event.value.coordinates[global_1.Global.index0];
            //Calculates where in the segments the intersection with the sweepline
            //lies.
            const lambda0 = (k - b.coordinates[global_1.Global.index0]) /
                (a.coordinates[global_1.Global.index0] - b.coordinates[global_1.Global.index0]);
            const lambda1 = (k - d.coordinates[global_1.Global.index0]) /
                (c.coordinates[global_1.Global.index0] - d.coordinates[global_1.Global.index0]);
            //The height difference between the intersections.
            let res = a.coordinates[global_1.Global.index1] * lambda0 +
                b.coordinates[global_1.Global.index1] * (1 - lambda0) -
                (c.coordinates[global_1.Global.index1] * lambda1 +
                    d.coordinates[global_1.Global.index1] * (1 - lambda1));
            //If the intersections are so similar, we also need to consider the
            //possibility that the edges actually have a common endpoint.
            if (Math.abs(res) &lt; global_1.Global.epsilon) {
                //If the first edge starts at a point, and the second ends at that point
                //then the former gets sorted after the latter.
                if (lambda0 > 1 - global_1.Global.epsilon &amp;&amp; lambda1 &lt; global_1.Global.epsilon)
                    return 1;
                //And viceversa.
                if (lambda0 &lt; global_1.Global.epsilon &amp;&amp; lambda1 > 1 - global_1.Global.epsilon)
                    return -1;
                //If both edges start at the same point, sort by increasing slope.
                if (lambda0 > 1 - global_1.Global.epsilon)
                    res = 1;
                //If both edges end at the same point, sort by decreasing slope.
                else if (lambda0 &lt; global_1.Global.epsilon)
                    res = -1;
                //The edges are just really close, so compare them normally.
                else
                    return res;
                //The difference between the slopes.
                res *= Math.atan(x.slope) - Math.atan(y.slope);
                //If both lines are the same, might as well compare using IDs.
                if (Math.abs(res) &lt; global_1.Global.epsilon)
                    return x.getId() - y.getId();
            }
            return res;
        }
        const P = P_.toPolytopeC().recenter();
        if (!P.elementList[0] || !P.elementList[1] || !P.elementList[2])
            return;
        //For each face:
        faceLoop: for (let i = 0; i &lt; P.elementList[2].length; i++) {
            //Let's not even bother with digons and monogons.
            if (P.elementList[2][i].length &lt; 3)
                continue faceLoop;
            /*	if(P.elementList[2][i].length === 3) {
                      //All triangles are convex, so cut to the chase and render it directly.
                  } */
            //Enumerates the vertices in order.
            const cycle = P.faceToVertices(i);
            //Makes a doubly-linked list vertexDLL for the polygon's vertices and the
            //new vertices created.
            //node0 is always the "next" vertex.
            //Every vertex should *always* have two adjacent vertices.
            Render.vertexDLL = [new linkedListNode_1.LinkedListNode(P.elementList[0][cycle[0]])];
            for (let j = 0; j &lt; cycle.length - 1; j++) {
                Render.vertexDLL[j + 1] = new linkedListNode_1.LinkedListNode(P.elementList[0][cycle[j + 1]]);
                Render.vertexDLL[j].linkToNext(Render.vertexDLL[j + 1]);
            }
            Render.vertexDLL[Render.vertexDLL.length - 1].linkToNext(Render.vertexDLL[0]);
            const v0 = Render.vertexDLL[0].value;
            //Tries to find two non-equal points. If all points are the same, doesn't
            //render the face.
            let a = 1;
            while (point_1.Point.equal(v0, Render.vertexDLL[a].value))
                if (++a >= Render.vertexDLL.length)
                    continue faceLoop;
            const va = Render.vertexDLL[a].value;
            //Tries to find three non-collinear points. If all points are collinear,
            //doesn't render the face.
            let b = a === 1 ? 2 : 1;
            while (space_1.Space.collinear(v0, va, Render.vertexDLL[b].value))
                if (++b >= Render.vertexDLL.length)
                    continue faceLoop;
            const vb = Render.vertexDLL[b].value;
            //Calculates the coordinates such that the projection of our three
            //non-collinear points onto their 2D plane has the highest area.
            //Uses the shoelace formula.
            //Stores such coordinates' indices in Global.index0, Global.index1.
            //That way, they become global variables that can be used elsewhere.
            let maxArea = 0, area;
            global_1.Global.index0 = 0;
            global_1.Global.index1 = 1;
            for (let j = 0; j &lt; v0.dimensions(); j++)
                for (let k = j + 1; k &lt; v0.dimensions(); k++)
                    if ((area = space_1.Space.area(v0, va, vb, j, k)) > maxArea) {
                        global_1.Global.index0 = j;
                        global_1.Global.index1 = k;
                        maxArea = area;
                    }
            //Event queue for Bentley-Ottmann, stores vertices.
            //Sorts EQ by lexicographic order of the vertices.
            Render.EQ = new avl_tree_1.AvlTree(Render._order);
            for (let j = 0; j &lt; Render.vertexDLL.length; j++)
                Render.EQ.insert(Render.vertexDLL[j]);
            //Bentley-Ottmann:
            while (!Render.EQ.isEmpty()) {
                const min = Render.EQ.findMinimum();
                if (!min)
                    throw new Error("EQ minimum not found!");
                Render.Event = min; //The next "event" in the event queue.
                Render.EQ.delete(Render.Event);
                //If the code worked perfectly, we could skip this expensive check.
                /*
                        if(!SL.checkSorted()) {
                            alert("Something went wrong!");
                            //return; //Uncomment if you want the code not to throw an exception.
                        }
                        */
                //Runs the code on both edges adjacent to E's vertex.
                for (let j = 0; j &lt;= 1; j++) {
                    const nodeJ = Render.Event.getNode(j);
                    if (!nodeJ)
                        throw new Error("Doubly linked list broken!");
                    const ord = Render.Event.value.coordinates[global_1.Global.index0] -
                        nodeJ.value.coordinates[global_1.Global.index0];
                    //Vertex E is a left endpoint of the edge:
                    if (ord &lt; -global_1.Global.epsilon) {
                        const edge = new sweeplineEdge_1.SweeplineEdge(Render.Event, j);
                        const node = SL.insert(edge);
                        if (!node) {
                            console.log("SL insertion failed! This isn't supposed to happen!");
                            console.log("Edge searched for: " + edge.toString());
                            console.log("Debug stuff:");
                            debug();
                            return;
                        }
                        const prevNode = SL.prev(node);
                        const nextNode = SL.next(node);
                        //Checks for an intersection with the edge below edgeE.
                        if (prevNode)
                            Render._divide(edge, prevNode.key);
                        //Checks for an intersection with the edge above edgeE.
                        if (nextNode)
                            Render._divide(edge, nextNode.key);
                    }
                    //Vertex E is a right endpoint of the edge:
                    else if (ord > global_1.Global.epsilon) {
                        const edge = new sweeplineEdge_1.SweeplineEdge(nodeJ, 1 - j);
                        //Deletes edge from the sweep line.
                        const node = SL.getNode(edge);
                        if (!node) {
                            console.log("SL retrieval failed! This isn't supposed to happen!");
                            console.log("Edge searched for: " + edge.toString());
                            console.log("Debug stuff:");
                            debug();
                            return;
                        }
                        const prevNode = SL.prev(node);
                        const nextNode = SL.next(node);
                        //Checks for an intersection between the edges below and above
                        //edgeE.
                        if (prevNode &amp;&amp; nextNode)
                            Render._divide(prevNode.key, nextNode.key);
                        SL.delete(edge);
                    }
                    //The edge is perpendicular to the first coordinate's axis:
                    //Runs only once per such an edge.
                    else if (Render.Event.value.coordinates[global_1.Global.index1] >
                        nodeJ.value.coordinates[global_1.Global.index1]) {
                        const edge = new sweeplineEdge_1.SweeplineEdge(Render.Event, j);
                        //I really should only check intersections with segments at the
                        //"correct height".
                        let node = SL.findMinimumNode();
                        while (node) {
                            Render._divide(edge, node.key);
                            node = SL.next(node);
                        }
                    }
                }
            }
            //Polygons composing a single face as ordered sets of vertices.
            const face = [];
            //Retrieves polygonal paths from edges.
            for (let j = 0; j &lt; Render.vertexDLL.length; j++) {
                if (!Render.vertexDLL[j].traversed)
                    face.push(Render.vertexDLL[j].getCycle());
            }
            //The rest of the rendering shenanigans are handled by the Scene class.
            scene.add(face);
        }
        scene.polytopes.push(P_);
    }
    /**
     * renderTo helper function.
     * "Cuts" two edges at the intersection point, adds the new directed edges
     * according to the simplification algorithm.
     * @private
     * @param {SLEdge} edgeA The first edge to cut.
     * @param {SLEdge} edgeB The second edge to cut.
     */
    static _divide(edgeA, edgeB) {
        //No point in doing anything if the intersection has already been dealt
        //with.
        //...what happens if two different vertices take the same location?
        if (edgeA.leftVertex.value === edgeB.leftVertex.value ||
            edgeA.leftVertex.value === edgeB.rightVertex().value ||
            edgeA.rightVertex().value === edgeB.leftVertex.value ||
            edgeA.rightVertex().value === edgeB.rightVertex().value)
            return;
        //Converts edges from the SL format to the [vertex1, vertex2] directed edge
        //format.
        const edgeADir = edgeA.directedEdge(), edgeBDir = edgeB.directedEdge();
        //No point in doing anything if the intersection is non-existent.
        const inter = space_1.Space.intersect(edgeADir[0].value, edgeADir[1].value, edgeBDir[0].value, edgeBDir[1].value);
        if (!inter)
            return;
        //Add the intersection and a point at "infinitesimal distance" to the vertex
        //list. They don't actually have to be different in this implementation of
        //the algorithm. In fact, the algorithm (as implemented) will fail if both
        //nodes don't reference the same point.
        const newNode1 = new linkedListNode_1.LinkedListNode(inter), newNode2 = new linkedListNode_1.LinkedListNode(inter);
        Render.vertexDLL.push(newNode1);
        Render.vertexDLL.push(newNode2);
        //Re-links the vertices.
        edgeADir[0].linkToNext(newNode1);
        newNode1.linkToNext(edgeBDir[1]);
        edgeBDir[0].linkToNext(newNode2);
        newNode2.linkToNext(edgeADir[1]);
        //Adds the edges' new IDs to the redirect table, so that they remain equal
        //and consistent.
        edgeA.updateRedirectTable();
        edgeB.updateRedirectTable();
        Render.EQ.insert(newNode1);
        Render.EQ.insert(newNode2);
    }
    /** Orders two points lexicographically based on the coordinates on indices 0
     * and 1. Uses the IDs of the vertices to order them consistently if their
     * coordinates are identical.
     * @private
     * @param {LinkedListNode&lt;Point>} a The first point to order.
     * @param {LinkedListNode&lt;Point>} b The second point to order.
     * @returns {number} 1, 0 or -1 depending on whether a > b, a = b or a &lt; b.
     */
    static _order(a, b) {
        let c = a.value.coordinates[global_1.Global.index0] - b.value.coordinates[global_1.Global.index0];
        if (c === 0) {
            //DO NOT REPLACE BY Math.abs(c) &lt; Global.epsilon
            c =
                a.value.coordinates[global_1.Global.index1] - b.value.coordinates[global_1.Global.index1];
            if (c === 0)
                return a.id - b.id;
        }
        return c;
    }
}
exports.Render = Render;
polytopeTypes_1.PolytopeB.prototype.renderTo = function (scene) {
    Render.to(this, scene);
};
//# sourceMappingURL=render.js.map</code></pre></article></section></div><br class="clear"><footer>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Sat Dec 26 2020 20:10:58 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.</footer><script>prettyPrint()</script><script src="scripts/polyfill.js"></script><script src="scripts/linenumber.js"></script><script src="scripts/search.js" defer="defer"></script><script src="scripts/collapse.js" defer="defer"></script></body></html>