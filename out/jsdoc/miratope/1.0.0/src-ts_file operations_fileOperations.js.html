<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>src-ts/file operations/fileOperations.js - Documentation</title><script src="scripts/prettify/prettify.js"></script><script src="scripts/prettify/lang-css.js"></script><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><link type="text/css" rel="stylesheet" href="styles/prettify.css"><link type="text/css" rel="stylesheet" href="styles/jsdoc.css"><script src="scripts/nav.js" defer="defer"></script><meta name="viewport" content="width=device-width,initial-scale=1"></head><body><input type="checkbox" id="nav-trigger" class="nav-trigger"> <label for="nav-trigger" class="navicon-button x"><div class="navicon"></div></label> <label for="nav-trigger" class="overlay"></label><nav><input type="text" id="nav-search" placeholder="Search"><h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/officialurl/miratope" target="_blank" class="menu-item" id="repository">Github repo</a></h2><h3>Classes</h3><ul><li><a href="AvlNode.html">AvlNode</a><ul class="methods"><li data-type="method" style="display:none"><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateRight">rotateRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateRight">rotateRight</a></li></ul></li><li></li><li><a href="AvlTree.html">AvlTree</a><ul class="methods"><li data-type="method" style="display:none"><a href="AvlTree.html#.getBalanceState">getBalanceState</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#.getBalanceState">getBalanceState</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#contains">contains</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#contains">contains</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#delete">delete</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#delete">delete</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#getNode">getNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#getNode">getNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#insert">insert</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#insert">insert</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#size">size</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#size">size</a></li></ul></li><li></li><li><a href="Caret.html">Caret</a><ul class="methods"><li data-type="method" style="display:none"><a href="Caret.html#advance">advance</a></li><li data-type="method" style="display:none"><a href="Caret.html#advance">advance</a></li><li data-type="method" style="display:none"><a href="Caret.html#getChar">getChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#getChar">getChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#increment">increment</a></li><li data-type="method" style="display:none"><a href="Caret.html#increment">increment</a></li><li data-type="method" style="display:none"><a href="Caret.html#readNumber">readNumber</a></li><li data-type="method" style="display:none"><a href="Caret.html#readNumber">readNumber</a></li><li data-type="method" style="display:none"><a href="Caret.html#readUntil">readUntil</a></li><li data-type="method" style="display:none"><a href="Caret.html#readUntil">readUntil</a></li><li data-type="method" style="display:none"><a href="Caret.html#readWord">readWord</a></li><li data-type="method" style="display:none"><a href="Caret.html#readWord">readWord</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToString">skipToString</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToString">skipToString</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type="method" style="display:none"><a href="Caret.html#throwError">throwError</a></li><li data-type="method" style="display:none"><a href="Caret.html#throwError">throwError</a></li></ul></li><li></li><li><a href="Point.html">Point</a><ul class="methods"><li data-type="method" style="display:none"><a href="Point.html#.padLeft">padLeft</a></li><li data-type="method" style="display:none"><a href="Point.html#.padLeft">padLeft</a></li><li data-type="method" style="display:none"><a href="Point.html#.padRight">padRight</a></li><li data-type="method" style="display:none"><a href="Point.html#.padRight">padRight</a></li><li data-type="method" style="display:none"><a href="Point.html#.product">product</a></li><li data-type="method" style="display:none"><a href="Point.html#.product">product</a></li><li data-type="method" style="display:none"><a href="Point.html#add">add</a></li><li data-type="method" style="display:none"><a href="Point.html#add">add</a></li><li data-type="method" style="display:none"><a href="Point.html#addCoordinate">addCoordinate</a></li><li data-type="method" style="display:none"><a href="Point.html#addCoordinate">addCoordinate</a></li><li data-type="method" style="display:none"><a href="Point.html#clone">clone</a></li><li data-type="method" style="display:none"><a href="Point.html#clone">clone</a></li><li data-type="method" style="display:none"><a href="Point.html#dimensions">dimensions</a></li><li data-type="method" style="display:none"><a href="Point.html#dimensions">dimensions</a></li><li data-type="method" style="display:none"><a href="Point.html#project">project</a></li><li data-type="method" style="display:none"><a href="Point.html#project">project</a></li><li data-type="method" style="display:none"><a href="Point.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="Point.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="Point.html#subtract">subtract</a></li><li data-type="method" style="display:none"><a href="Point.html#subtract">subtract</a></li></ul></li><li></li><li><a href="PolytopeC.html">PolytopeC</a><ul class="methods"><li data-type="method" style="display:none"><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#recenter">recenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#recenter">recenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li></ul></li><li></li><li><a href="Scene.html">Scene</a><ul class="methods"><li data-type="method" style="display:none"><a href="Scene.html#add">add</a></li><li data-type="method" style="display:none"><a href="Scene.html#add">add</a></li></ul></li><li></li><li><a href="SweeplineEdge.html">SweeplineEdge</a><ul class="methods"><li data-type="method" style="display:none"><a href="SweeplineEdge.html#getId">getId</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#getId">getId</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li></ul></li><li></li></ul><h3>Namespaces</h3><ul><li><a href="BalanceState.html">BalanceState</a></li><li></li><li><a href="ConstructionNodeType.html">ConstructionNodeType</a></li><li></li><li><a href="Space.html">Space</a><ul class="methods"><li data-type="method" style="display:none"><a href="Space.html#.area">area</a></li><li data-type="method" style="display:none"><a href="Space.html#.area">area</a></li><li data-type="method" style="display:none"><a href="Space.html#.distance">distance</a></li><li data-type="method" style="display:none"><a href="Space.html#.distance">distance</a></li><li data-type="method" style="display:none"><a href="Space.html#.distanceSq">distanceSq</a></li><li data-type="method" style="display:none"><a href="Space.html#.distanceSq">distanceSq</a></li><li data-type="method" style="display:none"><a href="Space.html#.intersect">intersect</a></li><li data-type="method" style="display:none"><a href="Space.html#.intersect">intersect</a></li><li data-type="method" style="display:none"><a href="Space.html#.sameSlope">sameSlope</a></li><li data-type="method" style="display:none"><a href="Space.html#.sameSlope">sameSlope</a></li></ul></li><li></li><li><a href="Translation.html">Translation</a><ul class="methods"><li data-type="method" style="display:none"><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type="method" style="display:none"><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type="method" style="display:none"><a href="Translation.html#.elementName">elementName</a></li><li data-type="method" style="display:none"><a href="Translation.html#.elementName">elementName</a></li><li data-type="method" style="display:none"><a href="Translation.html#.greekPrefix">greekPrefix</a></li><li data-type="method" style="display:none"><a href="Translation.html#.greekPrefix">greekPrefix</a></li></ul></li><li></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-dependencies.html">How to update Miratope's dependencies?</a></li><li><a href="tutorial-translation_.html">How to translate Miratope?</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BalanceState%255Bundefined%255D">BalanceState[undefined]</a></li><li><a href="global.html#CNType%255Bundefined%255D">CNType[undefined]</a></li></ul></nav><div id="main"><h1 class="page-title">src-ts/file operations/fileOperations.js</h1><section><article><pre class="prettyprint source linenums"><code>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileOperations = void 0;
const JSZip = require("jszip");
const constructionNode_1 = require("../data structures/constructionNode");
const graphNode_1 = require("../data structures/graphNode");
const point_1 = require("../geometry/point");
const polytopeBuild_1 = require("../polytopes/classes/polytopeBuild");
const polytopeTypes_1 = require("../polytopes/polytopeTypes");
const translation_1 = require("../translation/translation");
const caret_1 = require("./caret");
class FileOperations {
    /**
     * Helper function for {@link Polytope.openFile},
     * and more specifically for {@link Polytope._OFFReaderOnload}.
     * Checks whether two arrays have a common element using a dictionary.
     * @private
     * @param {number[]} a The first array to check.
     * @param {number[]} b The second array to check.
     * @returns {boolean} Whether the arrays have a common element or not.
     */
    static checkCommonElements(a, b) {
        const vals = [];
        vals[a[0]] = true;
        let i;
        for (i = 1; i &lt; a.length; i++) {
            if (vals[a[i]])
                return true;
            vals[a[i]] = true;
        }
        for (i = 0; i &lt; b.length - 1; i++) {
            if (vals[b[i]])
                return true;
            vals[b[i]] = true;
        }
        return !!vals[b[i]];
    }
    //Saves the file with the given data, the given MIME type,
    //and the given extension.
    static saveBlob(blob) {
        const fileName = FileOperations.fileName.replace("/", "_");
        if (navigator.msSaveOrOpenBlob)
            navigator.msSaveOrOpenBlob(blob, fileName);
        else {
            const a = document.getElementById("download");
            a.href = URL.createObjectURL(blob);
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(a.href);
        }
    }
    /**
     * Opens a file and stores it into the global variable `P`.
     * @param {Event | string} e Either the event triggered by the import button,
     * or a local filepath.
     * @todo Replace P by scene.polytope or something similar.
     * @todo Add support for more file formats.
     * @todo Rewrite the code with npm's fs.
     */
    static openFile(e) {
        //If e is an event.
        if (e instanceof Event) {
            const files = e.target.files;
            if (!files)
                return;
            const file = files[0];
            if (!file)
                return;
            const reader = new FileReader();
            //File name of imported polytope.
            //Stored in a global variable
            //so it can be accessed from Polytope._readerOnload.
            FileOperations.fileName = file.name;
            //Extracts the filename and extension.
            const i = FileOperations.fileName.lastIndexOf("."), 
            //Extension of file.
            ext = FileOperations.fileName.substr(i + 1);
            //Removes extension from file name.
            FileOperations.fileName = FileOperations.fileName.substr(0, i);
            if (translation_1.Translation.language !== "de")
                FileOperations.fileName = translation_1.Translation.firstToLower(FileOperations.fileName); //Lowercase name.
            //Handles the file according to its extension.
            switch (ext) {
                case "off":
                    reader.onload = function (e) {
                        FileOperations.onloadOFF(e.target.result);
                    };
                    reader.readAsText(file);
                    break;
                case "ggb":
                    reader.onload = function (e) {
                        if (e.target &amp;&amp; e.target.result)
                            JSZip.loadAsync(e.target.result).then(function (zip) {
                                const xml = zip.file("geogebra.xml");
                                if (xml)
                                    xml.async("string").then(FileOperations.onloadGGB);
                                else
                                    throw new Error("Invalid GeoGebra file!");
                            });
                    };
                    reader.readAsArrayBuffer(file);
                    break;
            }
        }
        //If e is a string.
        else {
            FileOperations.fileName = e;
            //Extracts the filename and extension.
            const i = FileOperations.fileName.lastIndexOf(".");
            //const ext = FileOperations.fileName.substr(i + 1); //Extension of file.
            //Removes extension from file name.
            FileOperations.fileName = FileOperations.fileName.substr(0, i);
            if (translation_1.Translation.language !== "de")
                FileOperations.fileName = translation_1.Translation.firstToLower(FileOperations.fileName); //Lowercase name.
            //Reads the file as an OFF file.
            const xhttp = new XMLHttpRequest();
            xhttp.onreadystatechange = function () {
                //this.status === 0 is for debug purposes only!
                if (this.readyState === 4 &amp;&amp; this.status === 200)
                    FileOperations.onloadOFF(this.responseText);
            };
            xhttp.open("GET", e, true);
            xhttp.send();
        }
    }
    /**
     * A GGB file is really just a ZIP file in disguise.
     * This ZIP file contains an XML called geogebra.xml.
     * This function will be called with this XML's data as a string.
     * It will store the 3D polyhedron into the global variable `P`.
     * @summary Stores the polyhedron described by an XML file
     * into the global variable `P`.
     * @private
     * @param {string} contents The contents of the file.
     * @todo Load the polyhedron into a scene,
     * instead of loading it into a global variable.
     */
    static onloadGGB(contents) {
        const caret = new caret_1.Caret(contents);
        const elementList = [[], [], [], []];
        //Dictionary to convert from GeoGebra point names to indices.
        const vertDict = {};
        //Dictionary to convert from edges to indices.
        const edgeDict = {};
        const lst = [
            '&lt;element type="point"',
            '&lt;element type="point3d"',
            '&lt;command name="Polygon">',
        ];
        let nextStringIndex;
        while ((nextStringIndex = caret.skipToStringList(lst)) != -1) {
            switch (nextStringIndex) {
                case 0: {
                    //Reading a 2D point.
                    //Reads the point name.
                    caret.skipToString('label="');
                    vertDict[caret.readUntil('"')] = elementList[0].length;
                    //Reads the coordinates.
                    caret.skipToString('&lt;coords x="');
                    let x = caret.readNumber();
                    caret.advance(5);
                    let y = caret.readNumber();
                    caret.advance(5);
                    let z = caret.readNumber();
                    caret.advance(5);
                    x /= z;
                    y /= z;
                    z /= z;
                    elementList[0].push(new point_1.Point([x, y, 0]));
                    break;
                }
                case 1: {
                    //Reading a 3D point.
                    //Reads the point name.
                    caret.skipToString('label="');
                    vertDict[caret.readUntil('"')] = elementList[0].length;
                    //Reads the coordinates.
                    caret.skipToString('&lt;coords x="');
                    let x = caret.readNumber();
                    caret.advance(5);
                    let y = caret.readNumber();
                    caret.advance(5);
                    let z = caret.readNumber();
                    caret.advance(5);
                    const w = caret.readNumber();
                    caret.advance(5);
                    x /= w;
                    y /= w;
                    z /= w;
                    elementList[0].push(new point_1.Point([x, y, z]));
                    break;
                }
                case 2: {
                    //Reading a polygon.
                    //Reads vertex names.
                    caret.skipToString("&lt;input a0=");
                    const verts = [];
                    while (caret.getChar() !== "/") {
                        caret.skipToChar('"');
                        caret.increment();
                        const str = caret.readUntil('"');
                        verts.push(vertDict[str]);
                        caret.increment();
                    }
                    verts.push(verts[0]); //Simulates a cyclic order.
                    //Adds edges.
                    const edges = [];
                    for (let i = 0; i &lt; verts.length - 1; i++) {
                        //Orders the edge, so that their key (identifier) is unique.
                        const edge = [verts[i], verts[i + 1]];
                        if (edge[0] > edge[1]) {
                            const t = edge[0];
                            edge[0] = edge[1];
                            edge[1] = t;
                        }
                        //Adds the edge to elementList if needed.
                        const key = edge[0] + "_" + edge[1];
                        if (edgeDict[key] === undefined) {
                            edgeDict[key] = elementList[1].length;
                            elementList[1].push(edge);
                        }
                        edges.push(edgeDict[key]);
                    }
                    //Adds faces.
                    elementList[2].push(edges);
                    break;
                }
            }
        }
        //Gets components.
        //Graph of incidences between facets.
        const graph = [];
        const facets = elementList[2];
        for (let i = 0; i &lt; facets.length; i++)
            graph.push(new graphNode_1.GraphNode(i));
        //Calculates incidences.
        for (let i = 0; i &lt; facets.length; i++)
            for (let j = i + 1; j &lt; facets.length; j++)
                if (FileOperations.checkCommonElements(facets[i], facets[j]))
                    graph[i].connectTo(graph[j]);
        //Gets components.
        for (let i = 0; i &lt; facets.length; i++) {
            const component = graph[i].getComponent();
            if (component)
                elementList[3].push(component);
        }
        globalThis.P = new polytopeTypes_1.PolytopeC(elementList);
    }
    /**
     * Helper function for {@link Polytope.openFile}.
     * Is called when an OFF file is loaded.
     * @param {string} contents The contents of the file.
     */
    static onloadOFF(contents) {
        //Caret for reading the OFF file.
        const caret = new caret_1.Caret(contents);
        //The number of dimensions of the OFF file's polytope.
        let dimensions = caret.readNumber();
        //A dictionary mapping hashes of pairs of integers to edge indices.
        const edgeList = [];
        //The amount of vertices, edges, faces...
        //elementCount[1] goes unused except for the special case of 2D components.
        const elementCount = [];
        //The elements of the described polytope.
        const elementList = [[]];
        //The file just starts with OFF.
        if (isNaN(dimensions))
            dimensions = 3;
        //Checks that the word OFF is the next thing on the file.
        if (caret.readWord() !== "OFF")
            caret.throwError("invalidFile");
        //Nullitope
        if (dimensions === -1) {
            globalThis.P = polytopeBuild_1.PolytopeBuild.nullitope();
            return;
        }
        //Point
        if (dimensions === 0) {
            globalThis.P = polytopeBuild_1.PolytopeBuild.point();
            return;
        }
        //Reads vertex amount.
        if (dimensions >= 1) {
            elementCount.push(caret.readNumber());
            elementList.push([]);
        }
        //Reads face and edge amounts.
        if (dimensions >= 3) {
            elementCount.push(0, caret.readNumber());
            //We *can't* actually care about the edge amount,
            //since Stella itself ignores it, and it's often set to 0.
            caret.readWord();
            elementList.push([], []);
        }
        //Reads component amount in the special 2OFF case.
        else if (dimensions === 2) {
            elementCount.push(0, caret.readNumber());
            elementList.push([]);
        }
        //Reads higher element amounts.
        for (let i = 3; i &lt; dimensions; i++) {
            elementCount.push(caret.readNumber());
            elementList.push([]);
        }
        //Adds vertices.
        for (let i = 0; i &lt; elementCount[0]; i++) {
            const coords = [];
            for (let j = 0; j &lt; dimensions; j++)
                coords.push(caret.readNumber());
            elementList[0].push(new point_1.Point(coords));
        }
        if (dimensions >= 2) {
            //Adds faces and edges (or compounds in the special case).
            for (let i = 0; i &lt; elementCount[2]; i++) {
                const indices = [];
                const face = [];
                const elCount = caret.readNumber();
                //Retrieves vertices.
                for (let j = 0; j &lt; elCount; j++)
                    indices.push(caret.readNumber());
                //Creates edges.
                for (let j = 0; j &lt; elCount - 1; j++) {
                    //Orders the edge's vertices.
                    let x = indices[j];
                    let y = indices[j + 1];
                    if (x &lt; y) {
                        const t = x;
                        x = y;
                        y = t;
                    }
                    const t = ((x + y + 1) * (x + y)) / 2 + y; //Cantor pairing function.
                    if (edgeList[t] === undefined) {
                        edgeList[t] = elementList[1].length;
                        elementList[1].push([x, y]);
                    }
                    face.push(edgeList[t]);
                }
                //Last edge.
                let x = indices[0];
                let y = indices[indices.length - 1];
                if (x &lt; y) {
                    const t = x;
                    x = y;
                    y = t;
                }
                const t = ((x + y + 1) * (x + y)) / 2 + y; //Cantor pairing function.
                if (edgeList[t] === undefined) {
                    edgeList[t] = elementList[1].length;
                    elementList[1].push([x, y]);
                }
                face.push(edgeList[t]);
                elementList[2].push(face);
            }
        }
        //Adds higher-dimensional elements.
        for (let i = 3; i &lt; dimensions; i++) {
            for (let j = 0; j &lt; elementCount[i]; j++) {
                const indices = [];
                const elCount = caret.readNumber();
                for (let t = 0; t &lt; elCount; t++)
                    indices.push(caret.readNumber());
                elementList[i].push(indices);
            }
        }
        //Gets components. The 1D case is trivial.
        if (dimensions === 1) {
            elementList[1].push([]);
            for (let i = 0; i &lt; elementCount[0]; i++)
                elementList[1][0].push(i);
        }
        //Gets components in higher dimensions, except in 2D,
        //where they've already been retrieved.
        else if (dimensions >= 3) {
            //Graph of incidences between facets.
            const graph = [];
            const facets = elementList[dimensions - 1];
            for (let i = 0; i &lt; facets.length; i++)
                graph.push(new graphNode_1.GraphNode(i));
            //Calculates incidences.
            for (let i = 0; i &lt; facets.length; i++)
                for (let j = i + 1; j &lt; facets.length; j++)
                    if (FileOperations.checkCommonElements(facets[i], facets[j]))
                        graph[i].connectTo(graph[j]);
            //Gets components.
            for (let i = 0; i &lt; facets.length; i++) {
                const component = graph[i].getComponent();
                if (component)
                    elementList[elementList.length - 1].push(component);
            }
        }
        globalThis.P = new polytopeTypes_1.PolytopeC(elementList, new constructionNode_1.CNName(FileOperations.fileName));
    }
}
exports.FileOperations = FileOperations;
//# sourceMappingURL=fileOperations.js.map</code></pre></article></section></div><br class="clear"><footer>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Sat Dec 26 2020 20:10:58 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.</footer><script>prettyPrint()</script><script src="scripts/polyfill.js"></script><script src="scripts/linenumber.js"></script><script src="scripts/search.js" defer="defer"></script><script src="scripts/collapse.js" defer="defer"></script></body></html>