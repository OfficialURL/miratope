<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>data structures/constructionNode.js - Documentation</title><script src="scripts/prettify/prettify.js"></script><script src="scripts/prettify/lang-css.js"></script><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><link type="text/css" rel="stylesheet" href="styles/prettify.css"><link type="text/css" rel="stylesheet" href="styles/jsdoc.css"><script src="scripts/nav.js" defer="defer"></script><meta name="viewport" content="width=device-width,initial-scale=1"></head><body><input type="checkbox" id="nav-trigger" class="nav-trigger"> <label for="nav-trigger" class="navicon-button x"><div class="navicon"></div></label> <label for="nav-trigger" class="overlay"></label><nav><input type="text" id="nav-search" placeholder="Search"><h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/officialurl/miratope" target="_blank" class="menu-item" id="repository">Github repo</a></h2><h3>Classes</h3><ul><li><a href="AvlNode.html">AvlNode</a><ul class="methods"><li data-type="method" style="display:none"><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateRight">rotateRight</a></li><li data-type="method" style="display:none"><a href="AvlNode.html#rotateRight">rotateRight</a></li></ul></li><li></li><li><a href="AvlTree.html">AvlTree</a><ul class="methods"><li data-type="method" style="display:none"><a href="AvlTree.html#.getBalanceState">getBalanceState</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#.getBalanceState">getBalanceState</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#contains">contains</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#contains">contains</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#delete">delete</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#delete">delete</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#getNode">getNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#getNode">getNode</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#insert">insert</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#insert">insert</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#size">size</a></li><li data-type="method" style="display:none"><a href="AvlTree.html#size">size</a></li></ul></li><li></li><li><a href="Caret.html">Caret</a><ul class="methods"><li data-type="method" style="display:none"><a href="Caret.html#advance">advance</a></li><li data-type="method" style="display:none"><a href="Caret.html#advance">advance</a></li><li data-type="method" style="display:none"><a href="Caret.html#getChar">getChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#getChar">getChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#increment">increment</a></li><li data-type="method" style="display:none"><a href="Caret.html#increment">increment</a></li><li data-type="method" style="display:none"><a href="Caret.html#readNumber">readNumber</a></li><li data-type="method" style="display:none"><a href="Caret.html#readNumber">readNumber</a></li><li data-type="method" style="display:none"><a href="Caret.html#readUntil">readUntil</a></li><li data-type="method" style="display:none"><a href="Caret.html#readUntil">readUntil</a></li><li data-type="method" style="display:none"><a href="Caret.html#readWord">readWord</a></li><li data-type="method" style="display:none"><a href="Caret.html#readWord">readWord</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToString">skipToString</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToString">skipToString</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type="method" style="display:none"><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type="method" style="display:none"><a href="Caret.html#throwError">throwError</a></li><li data-type="method" style="display:none"><a href="Caret.html#throwError">throwError</a></li></ul></li><li></li><li><a href="Point.html">Point</a><ul class="methods"><li data-type="method" style="display:none"><a href="Point.html#.padLeft">padLeft</a></li><li data-type="method" style="display:none"><a href="Point.html#.padLeft">padLeft</a></li><li data-type="method" style="display:none"><a href="Point.html#.padRight">padRight</a></li><li data-type="method" style="display:none"><a href="Point.html#.padRight">padRight</a></li><li data-type="method" style="display:none"><a href="Point.html#.product">product</a></li><li data-type="method" style="display:none"><a href="Point.html#.product">product</a></li><li data-type="method" style="display:none"><a href="Point.html#add">add</a></li><li data-type="method" style="display:none"><a href="Point.html#add">add</a></li><li data-type="method" style="display:none"><a href="Point.html#addCoordinate">addCoordinate</a></li><li data-type="method" style="display:none"><a href="Point.html#addCoordinate">addCoordinate</a></li><li data-type="method" style="display:none"><a href="Point.html#clone">clone</a></li><li data-type="method" style="display:none"><a href="Point.html#clone">clone</a></li><li data-type="method" style="display:none"><a href="Point.html#dimensions">dimensions</a></li><li data-type="method" style="display:none"><a href="Point.html#dimensions">dimensions</a></li><li data-type="method" style="display:none"><a href="Point.html#project">project</a></li><li data-type="method" style="display:none"><a href="Point.html#project">project</a></li><li data-type="method" style="display:none"><a href="Point.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="Point.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="Point.html#subtract">subtract</a></li><li data-type="method" style="display:none"><a href="Point.html#subtract">subtract</a></li></ul></li><li></li><li><a href="PolytopeC.html">PolytopeC</a><ul class="methods"><li data-type="method" style="display:none"><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#recenter">recenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#recenter">recenter</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#scale">scale</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li><li data-type="method" style="display:none"><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li></ul></li><li></li><li><a href="Scene.html">Scene</a><ul class="methods"><li data-type="method" style="display:none"><a href="Scene.html#add">add</a></li><li data-type="method" style="display:none"><a href="Scene.html#add">add</a></li></ul></li><li></li><li><a href="SweeplineEdge.html">SweeplineEdge</a><ul class="methods"><li data-type="method" style="display:none"><a href="SweeplineEdge.html#getId">getId</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#getId">getId</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li><li data-type="method" style="display:none"><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li></ul></li><li></li></ul><h3>Namespaces</h3><ul><li><a href="BalanceState.html">BalanceState</a></li><li></li><li><a href="ConstructionNodeType.html">ConstructionNodeType</a></li><li></li><li><a href="Space.html">Space</a><ul class="methods"><li data-type="method" style="display:none"><a href="Space.html#.area">area</a></li><li data-type="method" style="display:none"><a href="Space.html#.area">area</a></li><li data-type="method" style="display:none"><a href="Space.html#.distance">distance</a></li><li data-type="method" style="display:none"><a href="Space.html#.distance">distance</a></li><li data-type="method" style="display:none"><a href="Space.html#.distanceSq">distanceSq</a></li><li data-type="method" style="display:none"><a href="Space.html#.distanceSq">distanceSq</a></li><li data-type="method" style="display:none"><a href="Space.html#.intersect">intersect</a></li><li data-type="method" style="display:none"><a href="Space.html#.intersect">intersect</a></li><li data-type="method" style="display:none"><a href="Space.html#.sameSlope">sameSlope</a></li><li data-type="method" style="display:none"><a href="Space.html#.sameSlope">sameSlope</a></li></ul></li><li></li><li><a href="Translation.html">Translation</a><ul class="methods"><li data-type="method" style="display:none"><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type="method" style="display:none"><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type="method" style="display:none"><a href="Translation.html#.elementName">elementName</a></li><li data-type="method" style="display:none"><a href="Translation.html#.elementName">elementName</a></li><li data-type="method" style="display:none"><a href="Translation.html#.greekPrefix">greekPrefix</a></li><li data-type="method" style="display:none"><a href="Translation.html#.greekPrefix">greekPrefix</a></li></ul></li><li></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-dependencies.html">How to update Miratope's dependencies?</a></li><li><a href="tutorial-translation_.html">How to translate Miratope?</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BalanceState%255Bundefined%255D">BalanceState[undefined]</a></li><li><a href="global.html#CNType%255Bundefined%255D">CNType[undefined]</a></li></ul></nav><div id="main"><h1 class="page-title">data structures/constructionNode.js</h1><section><article><pre class="prettyprint source linenums"><code>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CNCross = exports.CNSimplex = exports.CNHypercube = exports.CNName = exports.CNCodename = exports.CNCupolaicBlend = exports.CNCuploid = exports.CNCupola = exports.CNPyramid = exports.CNAntiprism = exports.CNMultipyramid = exports.CNMultitegum = exports.CNMultiprism = exports.CNPolygon = exports.CNPlain = exports.ConstructionNode = exports.CNType = void 0;
const translation_1 = require("../translation/translation");
/**
 * An object containing the possible types of {@link ConstructionNode|ConstructionNodes}.
 * @enum {number}
 * @namespace ConstructionNodeType
 */
var CNType;
(function (CNType) {
    /**
     * The corresponding ConstructionNode has two children `[n, d]`,
     * representing the number of facets `n`
     * and the number of dimensions `d` of the polytope.
     * Its name is generated by {@linkcode Translation.plain}.
     */
    CNType[CNType["Plain"] = 0] = "Plain";
    /**
     * The corresponding ConstructionNode has two children `[n, d]`, representing
     * the regular polygon {`n`/`d`}.
     * Its name is generated by {@linkcode Translation.regularPolygonName}.
     */
    CNType[CNType["Polygon"] = 1] = "Polygon";
    /**
     * The corresponding ConstructionNode has an array with the factors of a prism
     * product as children.
     * Its name is generated by {@linkcode Translation.multiFamily}.
     */
    CNType[CNType["Multiprism"] = 2] = "Multiprism";
    /**
     * The corresponding ConstructionNode has an array with the factors of a tegum
     * product as children.
     * Its name is generated by {@linkcode Translation.multiFamily}.
     */
    CNType[CNType["Multitegum"] = 3] = "Multitegum";
    /**
     * The corresponding ConstructionNode has an array with the factors of a
     * pyramid product as children.
     * Its name is generated by {@linkcode Translation.multiFamily}.
     */
    CNType[CNType["Multipyramid"] = 4] = "Multipyramid";
    /**
     * The corresponding ConstructionNode has a single child representing the
     * antiprismatic base
     * Its name is generated by {@linkcode Translation.familyMember}.
     */
    CNType[CNType["Antiprism"] = 5] = "Antiprism";
    /**
     * The corresponding ConstructionNode has a single child representing the
     * pyramidal base.
     * Its name is generated by {@linkcode Translation.familyMember}.
     */
    CNType[CNType["Pyramid"] = 6] = "Pyramid";
    /**
     * The corresponding ConstructionNode has a single child representing the
     * cupoidal base.
     * Its name is generated by {@linkcode Translation.familyMember}.
     */
    CNType[CNType["Cupola"] = 7] = "Cupola";
    /**
     * The corresponding ConstructionNode has a single child representing the
     * cuploidal base.
     * Its name is generated by {@linkcode Translation.familyMember}.
     */
    CNType[CNType["Cuploid"] = 8] = "Cuploid";
    /**
     * The corresponding ConstructionNode has a single child representing the
     * cupolaic blend base.
     * Its name is generated by {@linkcode Translation.familyMember}.
     */
    CNType[CNType["CupolaicBlend"] = 9] = "CupolaicBlend";
    /**
     * The corresponding ConstructionNode has a polytope's "code name" as a child.
     * Used for polytopes whose names are in loadMessages.js.
     * Can be translated.
     * Its name is generated by {@linkcode Translation.get}.
     */
    CNType[CNType["Codename"] = 10] = "Codename";
    /**
     * The corresponding ConstructionNode has a polytope's name as a child.
     * The default for imported polytopes,
     * or polytopes not built out of anything else whose name is known.
     * Can **not** be translated.
     * Its name is just the ConstructionNode's child itslf.
     */
    CNType[CNType["Name"] = 11] = "Name";
    /**
     * The corresponding ConstructionNode has the dimension of a hypercube as a
     * child.
     * Its name is generated by {@linkcode Translation.hypercube}.
     */
    CNType[CNType["Hypercube"] = 12] = "Hypercube";
    /**
     * The corresponding ConstructionNode has the dimension of a simplex as a
     * child.
     * Its name is generated by {@linkcode Translation.simplex}.
     */
    CNType[CNType["Simplex"] = 13] = "Simplex";
    /**
     * The corresponding ConstructionNode has the dimension of an orthoplex as a
     * child.
     * Its name is generated by {@linkcode Translation.cross}.
     */
    CNType[CNType["Cross"] = 14] = "Cross";
})(CNType = exports.CNType || (exports.CNType = {}));
class ConstructionNode {
    constructor() {
        this.gender = "";
    }
    /**
     * A multiprism of multiprisms is just a larger multiprism,
     * a multitegum of multitegums is just a larger multitegum, etc.
     * This function removes children nodes of the same type
     * and replaces them by their children.
     * @private
     */
    mergeChildren() {
        //If the children are an array.
        if (this.child instanceof Array) {
            const oldLength = this.child.length;
            //For each of the array's members:
            for (let i = 0; i &lt; oldLength; i++) {
                //If the child is of the same type of construction node:
                if (this.child[i].type === this.type) {
                    const child = this.child[i].child;
                    //If the child is an array (this should always be true):
                    if (child instanceof Array) {
                        //Flatten the children array.
                        for (let j = 0; j &lt; child.length - 1; j++)
                            this.child.push(child.pop());
                        this.child[i] = child.pop();
                    }
                }
            }
        }
        else
            throw new Error("_mergeChildren can only be called in a product ConstructionNode!");
    }
    //Converts a nodeC into its the corresponding member of the specified family's
    //name.
    static familyMember(node, family, gender) {
        return translation_1.Translation.addAdjective(translation_1.Translation.toAdjective(node.getName(), gender), translation_1.Translation.get(family));
    }
    //Converts a set of ConstructionNodes into their prism product/tegum product/
    //pyramid product's name.
    //The family is which product is used ("prism", "tegum", "pyramid").
    //specialFactor is an element that, when in the product, is considered
    //differently.
    //specialFactorModify specifies what this element becomes into within the
    //product.
    //e.g. in a multiprism, specialFactor = "dyad", specialFactorModify = "prism".
    //In a multipyramid, specialFactor = "point", specialFactorModify = "pyramid".
    static multiFamily(nodes, family, specialFactor, specialFactorModify, gender) {
        const names = [];
        const FAMILY = translation_1.Translation.get(family), FAMILYADJ = translation_1.Translation.toAdjective(FAMILY, gender), SPECIAL = translation_1.Translation.get(specialFactor), SPECIALMOD = translation_1.Translation.get(specialFactorModify), SPECIALMODADJ = translation_1.Translation.toAdjective(SPECIALMOD, gender);
        let specialCount = 0, tempName, concatName, allNamesSame = true;
        //Counts special factors.
        for (let i = 0; i &lt; nodes.length; i++) {
            tempName = nodes[i].getName();
            if (tempName === SPECIAL)
                specialCount++;
            else
                names.push(tempName);
        }
        //The prefix before [family], e.g. *duo*[family], *trio*[family], ...
        let prefix;
        switch (names.length) {
            //All special factors.
            case 0:
                names.push(SPECIAL);
                specialCount--;
                prefix = "";
                break;
            case 1:
                prefix = "";
                break;
            case 2:
                prefix = "duo";
                break;
            case 3:
                prefix = "trio";
                break;
            default:
                prefix = translation_1.Translation.greekPrefix(names.length);
                break;
        }
        //names cannot be empty.
        tempName = names.pop();
        concatName = translation_1.Translation.toAdjective(tempName, gender);
        while (names.length > 0) {
            concatName +=
                "-" + translation_1.Translation.toAdjective(names[names.length - 1], gender);
            if (names.pop() !== tempName)
                allNamesSame = false;
        }
        if (!specialCount) {
            //X multi[family]
            if (allNamesSame)
                return translation_1.Translation.addAdjective(translation_1.Translation.toAdjective(tempName, gender), prefix + FAMILY);
            //X-Y-Z multi[family]
            return translation_1.Translation.addAdjective(concatName, prefix + FAMILY);
        }
        //Same as before, but adds as many ...[family-adj] [family]	as needed at the
        //end.
        if (allNamesSame)
            concatName = translation_1.Translation.toAdjective(tempName, gender);
        //We aren't calling a single polytope X an "X mono[family]", are we?
        if (prefix)
            concatName = translation_1.Translation.addAdjective(concatName, prefix + FAMILYADJ);
        while (--specialCount)
            concatName = translation_1.Translation.addAdjective(concatName, SPECIALMODADJ);
        return translation_1.Translation.addAdjective(concatName, SPECIALMOD);
    }
}
exports.ConstructionNode = ConstructionNode;
class CNPlain extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Plain;
        this.child = child;
        switch (translation_1.Translation.language) {
            case "es":
                this.gender = "male";
                break;
            case "de":
                this.gender = "neuter";
                break;
            default:
                this.gender = "";
        }
    }
    getName() {
        return translation_1.Translation.plainName(this.child[0], this.child[1]);
    }
    setGenders(gender) {
        this.gender = gender;
    }
}
exports.CNPlain = CNPlain;
class CNPolygon extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Polygon;
        this.child = child;
        switch (translation_1.Translation.language) {
            case "es":
                this.gender = "male";
                break;
            case "de":
                this.gender = "neuter";
                break;
            default:
                this.gender = "";
        }
    }
    getName() {
        return translation_1.Translation.regularPolygonName(this.child[0], this.child[1], {
            gender: this.gender,
        });
    }
    setGenders(gender) {
        this.gender = gender;
    }
}
exports.CNPolygon = CNPolygon;
class CNMultiprism extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Multiprism;
        this.child = child;
        switch (translation_1.Translation.language) {
            case "es":
                this.gender = "male";
                break;
            case "de":
                this.gender = "neuter";
                break;
            default:
                this.gender = "";
        }
    }
    getName() {
        this.mergeChildren();
        return ConstructionNode.multiFamily(this.child, "family/prism", "shape/dyad", "family/prism", this.gender);
    }
    setGenders(gender) {
        this.gender = gender;
        for (let i = 0; i &lt; this.child.length; i++)
            this.child[i].setGenders(gender);
    }
}
exports.CNMultiprism = CNMultiprism;
class CNMultitegum extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Multitegum;
        this.child = child;
        switch (translation_1.Translation.language) {
            case "es":
                this.gender = "male";
                break;
            case "de":
                this.gender = "neuter";
                break;
            default:
                this.gender = "";
        }
    }
    getName() {
        this.mergeChildren();
        return ConstructionNode.multiFamily(this.child, "family/tegum", "shape/dyad", "family/bipyramid", this.gender);
    }
    setGenders(gender) {
        this.gender = gender;
        for (let i = 0; i &lt; this.child.length; i++)
            this.child[i].setGenders(gender);
    }
}
exports.CNMultitegum = CNMultitegum;
class CNMultipyramid extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Multipyramid;
        this.child = child;
        switch (translation_1.Translation.language) {
            case "es":
            case "de":
                this.gender = "female";
                break;
            default:
                this.gender = "";
        }
    }
    getName() {
        this.mergeChildren();
        return ConstructionNode.multiFamily(this.child, "family/pyramid", "shape/point", "family/pyramid", this.gender);
    }
    setGenders(gender) {
        this.gender = gender;
        for (let i = 0; i &lt; this.child.length; i++)
            this.child[i].setGenders(gender);
    }
}
exports.CNMultipyramid = CNMultipyramid;
class CNAntiprism extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Antiprism;
        this.child = child;
        switch (translation_1.Translation.language) {
            case "es":
                this.gender = "male";
                break;
            case "de":
                this.gender = "neuter";
                break;
            default:
                this.gender = "";
        }
    }
    getName() {
        return ConstructionNode.familyMember(this.child, "family/antiprism", this.gender);
    }
    setGenders(gender) {
        this.gender = gender;
        this.child.setGenders(gender);
    }
}
exports.CNAntiprism = CNAntiprism;
class CNPyramid extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Pyramid;
        this.child = child;
        switch (translation_1.Translation.language) {
            case "es":
            case "de":
                this.gender = "female";
                break;
            default:
                this.gender = "";
        }
    }
    getName() {
        return ConstructionNode.familyMember(this.child, "family/pyramid", this.gender);
    }
    setGenders(gender) {
        this.gender = gender;
        this.child.setGenders(gender);
    }
}
exports.CNPyramid = CNPyramid;
class CNCupola extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Cupola;
        this.child = child;
        switch (translation_1.Translation.language) {
            case "es":
            case "de":
                this.gender = "female";
                break;
            default:
                this.gender = "";
        }
    }
    getName() {
        return ConstructionNode.familyMember(this.child, "family/cupola", this.gender);
    }
    setGenders(gender) {
        this.gender = gender;
        this.child.setGenders(gender);
    }
}
exports.CNCupola = CNCupola;
class CNCuploid extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Cuploid;
        this.child = child;
        switch (translation_1.Translation.language) {
            case "es":
                this.gender = "male";
                break;
            default:
                this.gender = "";
        }
    }
    getName() {
        return ConstructionNode.familyMember(this.child, "family/cuploid", this.gender);
    }
    setGenders(gender) {
        this.gender = gender;
        this.child.setGenders(gender);
    }
}
exports.CNCuploid = CNCuploid;
class CNCupolaicBlend extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.CupolaicBlend;
        this.child = child;
        switch (translation_1.Translation.language) {
            case "es":
            case "de":
                this.gender = "female";
                break;
            default:
                this.gender = "";
        }
    }
    getName() {
        return ConstructionNode.familyMember(this.child, "family/cupolaicBlend", this.gender);
    }
    setGenders(gender) {
        this.gender = gender;
    }
}
exports.CNCupolaicBlend = CNCupolaicBlend;
class CNCodename extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Codename;
        this.child = child;
        this.gender = "";
    }
    getName() {
        return translation_1.Translation.get("shape/" + this.child, { gender: this.gender });
    }
    setGenders(gender) {
        this.gender = gender;
    }
}
exports.CNCodename = CNCodename;
class CNName extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Codename;
        this.child = child;
        this.gender = "";
    }
    getName() {
        return this.child;
    }
    setGenders(gender) {
        this.gender = gender;
    }
}
exports.CNName = CNName;
class CNHypercube extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Hypercube;
        this.child = child;
        this.gender = "";
    }
    getName() {
        return translation_1.Translation.hypercube(this.child);
    }
    setGenders(gender) {
        this.gender = gender;
    }
}
exports.CNHypercube = CNHypercube;
class CNSimplex extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Simplex;
        this.child = child;
        this.gender = "";
    }
    getName() {
        return translation_1.Translation.simplex(this.child);
    }
    setGenders(gender) {
        this.gender = gender;
    }
}
exports.CNSimplex = CNSimplex;
class CNCross extends ConstructionNode {
    constructor(child) {
        super();
        this.type = CNType.Cross;
        this.child = child;
        this.gender = "";
    }
    getName() {
        return translation_1.Translation.cross(this.child);
    }
    setGenders(gender) {
        this.gender = gender;
    }
}
exports.CNCross = CNCross;
//# sourceMappingURL=constructionNode.js.map</code></pre></article></section></div><br class="clear"><footer>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Sat Dec 26 2020 20:10:58 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.</footer><script>prettyPrint()</script><script src="scripts/polyfill.js"></script><script src="scripts/linenumber.js"></script><script src="scripts/search.js" defer="defer"></script><script src="scripts/collapse.js" defer="defer"></script></body></html>