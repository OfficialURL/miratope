<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>rendering/trackball-controls.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/officialurl/miratope" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h3>Classes</h3><ul><li><a href="AvlNode.html">AvlNode</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rotateRight">rotateRight</a></li></ul></li><li><a href="AvlTree.html">AvlTree</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AvlTree.html#.getBalanceState">getBalanceState</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#contains">contains</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#getNode">getNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#insert">insert</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#size">size</a></li></ul></li><li><a href="Caret.html">Caret</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Caret.html#advance">advance</a></li><li data-type='method' style='display: none;'><a href="Caret.html#getChar">getChar</a></li><li data-type='method' style='display: none;'><a href="Caret.html#increment">increment</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readNumber">readNumber</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readUntil">readUntil</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readWord">readWord</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToString">skipToString</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type='method' style='display: none;'><a href="Caret.html#throwError">throwError</a></li></ul></li><li><a href="Point.html">Point</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Point.html#.padLeft">padLeft</a></li><li data-type='method' style='display: none;'><a href="Point.html#.padRight">padRight</a></li><li data-type='method' style='display: none;'><a href="Point.html#.product">product</a></li><li data-type='method' style='display: none;'><a href="Point.html#add">add</a></li><li data-type='method' style='display: none;'><a href="Point.html#addCoordinate">addCoordinate</a></li><li data-type='method' style='display: none;'><a href="Point.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="Point.html#dimensions">dimensions</a></li><li data-type='method' style='display: none;'><a href="Point.html#project">project</a></li><li data-type='method' style='display: none;'><a href="Point.html#scale">scale</a></li><li data-type='method' style='display: none;'><a href="Point.html#subtract">subtract</a></li></ul></li><li><a href="PolytopeC.html">PolytopeC</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#recenter">recenter</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#scale">scale</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li></ul></li><li><a href="Scene.html">Scene</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Scene.html#add">add</a></li></ul></li><li><a href="SweeplineEdge.html">SweeplineEdge</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SweeplineEdge.html#getId">getId</a></li><li data-type='method' style='display: none;'><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type='method' style='display: none;'><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="BalanceState.html">BalanceState</a></li><li><a href="ConstructionNodeType.html">ConstructionNodeType</a></li><li><a href="Space.html">Space</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Space.html#.area">area</a></li><li data-type='method' style='display: none;'><a href="Space.html#.distance">distance</a></li><li data-type='method' style='display: none;'><a href="Space.html#.distanceSq">distanceSq</a></li><li data-type='method' style='display: none;'><a href="Space.html#.intersect">intersect</a></li><li data-type='method' style='display: none;'><a href="Space.html#.sameSlope">sameSlope</a></li></ul></li><li><a href="Translation.html">Translation</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type='method' style='display: none;'><a href="Translation.html#.elementName">elementName</a></li><li data-type='method' style='display: none;'><a href="Translation.html#.greekPrefix">greekPrefix</a></li></ul></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-dependencies.html">How to update Miratope's dependencies?</a></li><li><a href="tutorial-translation_.html">How to translate Miratope?</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BalanceState%255Bundefined%255D">BalanceState[undefined]</a></li><li><a href="global.html#CNType%255Bundefined%255D">CNType[undefined]</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">rendering/trackball-controls.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
/**
 * @author Eberhard Graether / http://egraether.com/
 * @author Mark Lundin 	/ http://mark-lundin.com
 * @author Simone Manini / http://daron1337.github.io
 * @author Luca Antiga 	/ http://lantiga.github.io

 ** three-trackballcontrols module
 ** @author Jon Lim / https://jonlim.ca
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackballControls = void 0;
const THREE = require("three");
const EPS = 0.000001;
var STATE;
(function (STATE) {
    STATE[STATE["NONE"] = -1] = "NONE";
    STATE[STATE["ROTATE"] = 0] = "ROTATE";
    STATE[STATE["ZOOM"] = 1] = "ZOOM";
    STATE[STATE["PAN"] = 2] = "PAN";
    STATE[STATE["TOUCH_ROTATE"] = 3] = "TOUCH_ROTATE";
    STATE[STATE["TOUCH_ZOOM_PAN"] = 4] = "TOUCH_ZOOM_PAN";
})(STATE || (STATE = {}));
const EVENT = {
    change: { type: 'change' },
    start: { type: 'start' },
    end: { type: 'end' }
};
class TrackballControls extends THREE.EventDispatcher {
    constructor(object, domElement) {
        super();
        //API
        this.enabled = true;
        this.screen = { left: 0, top: 0, width: 0, height: 0 };
        this.rotateSpeed = 1.0;
        this.zoomSpeed = 1.2;
        this.panSpeed = 0.3;
        this.noRotate = false;
        this.noZoom = false;
        this.noPan = false;
        this.staticMoving = false;
        this.dynamicDampingFactor = 0.2;
        this.minDistance = 0;
        this.maxDistance = Infinity;
        this.target = new THREE.Vector3();
        this.lastPosition = new THREE.Vector3();
        //internals
        this.state = STATE.NONE;
        this.keyState = STATE.NONE;
        this.eye = new THREE.Vector3();
        this.moveCurr = new THREE.Vector2();
        this.movePrev = new THREE.Vector2();
        this.lastAxis = new THREE.Vector3();
        this.lastAngle = 0;
        this.zoomStart = new THREE.Vector2();
        this.zoomEnd = new THREE.Vector2();
        this.touchZoomDistanceStart = 0;
        this.touchZoomDistanceEnd = 0;
        this.panStart = new THREE.Vector2();
        this.panEnd = new THREE.Vector2();
        /**
         * `KeyboardEvent.keyCode` values which should trigger the different
         * interaction states. Each element can be a single code or an array
         * of codes. All elements are required.
         */
        this.keys = [
            "a", "s", "d"
        ];
        /**
         * `Event` for pointer interactions which should trigger different
         * interaction states.
         */
        this.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.MIDDLE,
            RIGHT: THREE.MOUSE.PAN,
        };
        this.object = object;
        this.domElement = domElement;
        //Terrible hack, fix this pls
        globalThis.trackball = this;
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.up0 = this.object.up.clone();
        this.zoom0 = this.object.zoom;
        this.domElement.addEventListener('contextmenu', TrackballControls.contextmenu, false);
        this.domElement.addEventListener('pointerdown', TrackballControls.onPointerDown, false);
        this.domElement.addEventListener('wheel', TrackballControls.mousewheel, false);
        this.domElement.addEventListener('touchstart', TrackballControls.touchstart, false);
        this.domElement.addEventListener('touchend', TrackballControls.touchend, false);
        this.domElement.addEventListener('touchmove', TrackballControls.touchmove, false);
        this.domElement.ownerDocument.addEventListener('pointermove', TrackballControls.onPointerMove, false);
        this.domElement.ownerDocument.addEventListener('pointerup', TrackballControls.onPointerUp, false);
        globalThis.addEventListener('keydown', TrackballControls.keydown, false);
        globalThis.addEventListener('keyup', TrackballControls.keyup, false);
        this.handleResize();
        // force an update at start
        //this.update();
    }
    handleResize() {
        const box = this.domElement.getBoundingClientRect();
        // Adjustments come from similar code in the jquery offset() function.
        const d = this.domElement.ownerDocument.documentElement;
        this.screen.left = box.left + globalThis.pageXOffset - d.clientLeft;
        this.screen.top = box.top + globalThis.pageYOffset - d.clientTop;
        this.screen.width = box.width;
        this.screen.height = box.height;
    }
    getMouseOnScreen(pageX, pageY) {
        return new THREE.Vector2((pageX - this.screen.left) / this.screen.width, (pageY - this.screen.top) / this.screen.height);
    }
    getMouseOnCircle(pageX, pageY) {
        return new THREE.Vector2(((pageX - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5)), ((this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width));
    }
    rotateCamera() {
        let axis = new THREE.Vector3(), quaternion = new THREE.Quaternion(), eyeDirection = new THREE.Vector3(), objectUpDirection = new THREE.Vector3(), objectSidewaysDirection = new THREE.Vector3(), moveDirection = new THREE.Vector3(), angle;
        moveDirection.set(this.moveCurr.x - this.movePrev.x, this.moveCurr.y - this.movePrev.y, 0);
        angle = moveDirection.length();
        if (angle) {
            this.eye.copy(this.object.position).sub(this.target);
            eyeDirection.copy(this.eye).normalize();
            objectUpDirection.copy(this.object.up).normalize();
            objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();
            objectUpDirection.setLength(this.moveCurr.y - this.movePrev.y);
            objectSidewaysDirection.setLength(this.moveCurr.x - this.movePrev.x);
            moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));
            axis.crossVectors(moveDirection, this.eye).normalize();
            angle *= this.rotateSpeed;
            quaternion.setFromAxisAngle(axis, angle);
            this.eye.applyQuaternion(quaternion);
            this.object.up.applyQuaternion(quaternion);
            this.lastAxis.copy(axis);
            this.lastAngle = angle;
        }
        else if (!this.staticMoving &amp;&amp; this.lastAngle) {
            this.lastAngle *= Math.sqrt(1.0 - this.dynamicDampingFactor);
            this.eye.copy(this.object.position).sub(this.target);
            quaternion.setFromAxisAngle(this.lastAxis, this.lastAngle);
            this.eye.applyQuaternion(quaternion);
            this.object.up.applyQuaternion(quaternion);
        }
        this.movePrev.copy(this.moveCurr);
    }
    zoomCamera() {
        let factor;
        if (this.state === STATE.TOUCH_ZOOM_PAN) {
            factor = this.touchZoomDistanceStart / this.touchZoomDistanceEnd;
            this.touchZoomDistanceStart = this.touchZoomDistanceEnd;
            this.eye.multiplyScalar(factor);
        }
        else {
            factor = 1.0 + (this.zoomEnd.y - this.zoomStart.y) * this.zoomSpeed;
            if (factor !== 1.0 &amp;&amp; factor > 0.0)
                this.eye.multiplyScalar(factor);
            if (this.staticMoving)
                this.zoomStart.copy(this.zoomEnd);
            else
                this.zoomStart.y += (this.zoomEnd.y - this.zoomStart.y) * this.dynamicDampingFactor;
        }
    }
    panCamera() {
        const mouseChange = new THREE.Vector2(), objectUp = new THREE.Vector3(), pan = new THREE.Vector3();
        mouseChange.copy(this.panEnd).sub(this.panStart);
        if (mouseChange.lengthSq()) {
            mouseChange.multiplyScalar(this.eye.length() * this.panSpeed);
            pan.copy(this.eye).cross(this.object.up).setLength(mouseChange.x);
            pan.add(objectUp.copy(this.object.up).setLength(mouseChange.y));
            this.object.position.add(pan);
            this.target.add(pan);
            if (this.staticMoving)
                this.panStart.copy(this.panEnd);
            else
                this.panStart.add(mouseChange.subVectors(this.panEnd, this.panStart).multiplyScalar(this.dynamicDampingFactor));
        }
    }
    checkDistances() {
        if (!this.noZoom || !this.noPan) {
            if (this.eye.lengthSq() > this.maxDistance * this.maxDistance) {
                this.object.position.addVectors(this.target, this.eye.setLength(this.maxDistance));
                this.zoomStart.copy(this.zoomEnd);
            }
            if (this.eye.lengthSq() &lt; this.minDistance * this.minDistance) {
                this.object.position.addVectors(this.target, this.eye.setLength(this.minDistance));
                this.zoomStart.copy(this.zoomEnd);
            }
        }
    }
    update() {
        this.eye.subVectors(this.object.position, this.target);
        if (!this.noRotate)
            this.rotateCamera();
        if (!this.noZoom)
            this.zoomCamera();
        if (!this.noPan)
            this.panCamera();
        this.object.position.addVectors(this.target, this.eye);
        this.checkDistances();
        this.object.lookAt(this.target);
        if (this.lastPosition.distanceToSquared(this.object.position) > EPS) {
            this.dispatchEvent(EVENT.change);
            this.lastPosition.copy(this.object.position);
        }
    }
    reset() {
        this.state = STATE.NONE;
        this.keyState = STATE.NONE;
        this.target.copy(this.target0);
        this.object.position.copy(this.position0);
        this.object.up.copy(this.up0);
        this.object.zoom = this.zoom0;
        this.eye.subVectors(this.object.position, this.target);
        this.object.lookAt(this.target);
        this.dispatchEvent(EVENT.change);
        this.lastPosition.copy(this.object.position);
    }
    // Listeners
    static onPointerDown(event) {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        switch (event.pointerType) {
            case 'mouse':
            case 'pen':
                TrackballControls.onMouseDown(event);
                break;
            // TODO touch
        }
    }
    static onPointerMove(event) {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        switch (event.pointerType) {
            case 'mouse':
            case 'pen':
                TrackballControls.onMouseMove(event);
                break;
            // TODO touch
        }
    }
    static onPointerUp(event) {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        switch (event.pointerType) {
            case 'mouse':
            case 'pen':
                TrackballControls.onMouseUp(event);
                break;
            // TODO touch
        }
    }
    static keydown(event) {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        globalThis.removeEventListener('keydown', TrackballControls.keydown);
        if (trackball.keyState !== STATE.NONE)
            return;
        else if (event.key === trackball.keys[STATE.ROTATE] &amp;&amp; !trackball.noRotate)
            trackball.keyState = STATE.ROTATE;
        else if (event.key === trackball.keys[STATE.ZOOM] &amp;&amp; !trackball.noZoom)
            trackball.keyState = STATE.ZOOM;
        else if (event.key === trackball.keys[STATE.PAN] &amp;&amp; !trackball.noPan)
            trackball.keyState = STATE.PAN;
    }
    static keyup() {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        trackball.keyState = STATE.NONE;
        globalThis.addEventListener('keydown', TrackballControls.keydown, false);
    }
    static onMouseDown(event) {
        const trackball = globalThis.trackball;
        event.preventDefault();
        event.stopPropagation();
        if (trackball.state === STATE.NONE) {
            switch (event.button) {
                case trackball.mouseButtons.LEFT:
                    trackball.state = STATE.ROTATE;
                    break;
                case trackball.mouseButtons.MIDDLE:
                    trackball.state = STATE.ZOOM;
                    break;
                case trackball.mouseButtons.RIGHT:
                    trackball.state = STATE.PAN;
                    break;
                default:
                    trackball.state = STATE.NONE;
            }
        }
        const state = (trackball.keyState !== STATE.NONE) ? trackball.keyState : trackball.state;
        if (state === STATE.ROTATE &amp;&amp; !trackball.noRotate) {
            trackball.moveCurr.copy(trackball.getMouseOnCircle(event.pageX, event.pageY));
            trackball.movePrev.copy(trackball.moveCurr);
        }
        else if (state === STATE.ZOOM &amp;&amp; !trackball.noZoom) {
            trackball.zoomStart.copy(trackball.getMouseOnScreen(event.pageX, event.pageY));
            trackball.zoomEnd.copy(trackball.zoomStart);
        }
        else if (state === STATE.PAN &amp;&amp; !trackball.noPan) {
            trackball.panStart.copy(trackball.getMouseOnScreen(event.pageX, event.pageY));
            trackball.panEnd.copy(trackball.panStart);
        }
        trackball.domElement.ownerDocument.addEventListener('pointermove', TrackballControls.onPointerMove, false);
        trackball.domElement.ownerDocument.addEventListener('pointerup', TrackballControls.onPointerUp, false);
        trackball.dispatchEvent(EVENT.start);
    }
    static onMouseMove(event) {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        event.preventDefault();
        event.stopPropagation();
        const state = (trackball.keyState !== STATE.NONE) ? trackball.keyState : trackball.state;
        if (state === STATE.ROTATE &amp;&amp; !trackball.noRotate) {
            trackball.movePrev.copy(trackball.moveCurr);
            trackball.moveCurr.copy(trackball.getMouseOnCircle(event.pageX, event.pageY));
        }
        else if (state === STATE.ZOOM &amp;&amp; !trackball.noZoom)
            trackball.zoomEnd.copy(trackball.getMouseOnScreen(event.pageX, event.pageY));
        else if (state === STATE.PAN &amp;&amp; !trackball.noPan)
            trackball.panEnd.copy(trackball.getMouseOnScreen(event.pageX, event.pageY));
    }
    static onMouseUp(event) {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        event.preventDefault();
        event.stopPropagation();
        trackball.state = STATE.NONE;
        trackball.domElement.ownerDocument.removeEventListener('pointermove', TrackballControls.onPointerMove);
        trackball.domElement.ownerDocument.removeEventListener('pointerup', TrackballControls.onPointerUp);
        trackball.dispatchEvent(EVENT.end);
    }
    static mousewheel(event) {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        if (trackball.noZoom === true)
            return;
        event.preventDefault();
        event.stopPropagation();
        switch (event.deltaMode) {
            case 2:
                // Zoom in pages
                trackball.zoomStart.y -= event.deltaY * 0.025;
                break;
            case 1:
                // Zoom in lines
                trackball.zoomStart.y -= event.deltaY * 0.01;
                break;
            default:
                // undefined, 0, assume pixels
                trackball.zoomStart.y -= event.deltaY * 0.00025;
                break;
        }
        trackball.dispatchEvent(EVENT.start);
        trackball.dispatchEvent(EVENT.start);
    }
    static touchstart(event) {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        event.preventDefault();
        switch (event.touches.length) {
            case 1:
                trackball.state = STATE.TOUCH_ROTATE;
                trackball.moveCurr.copy(trackball.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
                trackball.movePrev.copy(trackball.moveCurr);
                break;
            default: // 2 or more
                trackball.state = STATE.TOUCH_ZOOM_PAN;
                var dx = event.touches[0].pageX - event.touches[1].pageX;
                var dy = event.touches[0].pageY - event.touches[1].pageY;
                trackball.touchZoomDistanceEnd = trackball.touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
                trackball.panStart.copy(trackball.getMouseOnScreen(x, y));
                trackball.panEnd.copy(trackball.panStart);
                break;
        }
        trackball.dispatchEvent(EVENT.start);
    }
    static touchmove(event) {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        event.preventDefault();
        event.stopPropagation();
        switch (event.touches.length) {
            case 1:
                trackball.movePrev.copy(trackball.moveCurr);
                trackball.moveCurr.copy(trackball.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
                break;
            default: // 2 or more
                var dx = event.touches[0].pageX - event.touches[1].pageX;
                var dy = event.touches[0].pageY - event.touches[1].pageY;
                trackball.touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
                var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
                var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
                trackball.panEnd.copy(trackball.getMouseOnScreen(x, y));
                break;
        }
    }
    static touchend(event) {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        switch (event.touches.length) {
            case 0:
                trackball.state = STATE.NONE;
                break;
            case 1:
                trackball.state = STATE.TOUCH_ROTATE;
                trackball.moveCurr.copy(trackball.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
                trackball.movePrev.copy(trackball.moveCurr);
                break;
        }
        trackball.dispatchEvent(EVENT.end);
    }
    static contextmenu(event) {
        const trackball = globalThis.trackball;
        if (!trackball.enabled)
            return;
        event.preventDefault();
    }
    dispose() {
        this.domElement.removeEventListener('contextmenu', TrackballControls.contextmenu, false);
        this.domElement.removeEventListener('pointerdown', TrackballControls.onPointerDown, false);
        this.domElement.removeEventListener('wheel', TrackballControls.mousewheel, false);
        this.domElement.removeEventListener('touchstart', TrackballControls.touchstart, false);
        this.domElement.removeEventListener('touchend', TrackballControls.touchend, false);
        this.domElement.removeEventListener('touchmove', TrackballControls.touchmove, false);
        this.domElement.ownerDocument.removeEventListener('pointermove', TrackballControls.onPointerMove, false);
        this.domElement.ownerDocument.removeEventListener('pointerup', TrackballControls.onPointerUp, false);
        globalThis.removeEventListener('keydown', TrackballControls.keydown, false);
        globalThis.removeEventListener('keyup', TrackballControls.keyup, false);
    }
}
exports.TrackballControls = TrackballControls;
//# sourceMappingURL=trackball-controls.js.map</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Fri Dec 25 2020 17:40:45 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
