<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>polytopes/classes/polytopeBuild.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/officialurl/miratope" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h3>Classes</h3><ul><li><a href="AvlNode.html">AvlNode</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AvlNode.html#leftHeight">leftHeight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#linkLeft">linkLeft</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#linkRight">linkRight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rightHeight">rightHeight</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rotateLeft">rotateLeft</a></li><li data-type='method' style='display: none;'><a href="AvlNode.html#rotateRight">rotateRight</a></li></ul></li><li><a href="AvlTree.html">AvlTree</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AvlTree.html#.getBalanceState">getBalanceState</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#contains">contains</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMaximum">findMaximum</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMaximumNode">findMaximumNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMinimum">findMinimum</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#findMinimumNode">findMinimumNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#getNode">getNode</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#insert">insert</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#isEmpty">isEmpty</a></li><li data-type='method' style='display: none;'><a href="AvlTree.html#size">size</a></li></ul></li><li><a href="Caret.html">Caret</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Caret.html#advance">advance</a></li><li data-type='method' style='display: none;'><a href="Caret.html#getChar">getChar</a></li><li data-type='method' style='display: none;'><a href="Caret.html#increment">increment</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readNumber">readNumber</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readUntil">readUntil</a></li><li data-type='method' style='display: none;'><a href="Caret.html#readWord">readWord</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToChar">skipToChar</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToContent">skipToContent</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToString">skipToString</a></li><li data-type='method' style='display: none;'><a href="Caret.html#skipToStringList">skipToStringList</a></li><li data-type='method' style='display: none;'><a href="Caret.html#throwError">throwError</a></li></ul></li><li><a href="Point.html">Point</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Point.html#.padLeft">padLeft</a></li><li data-type='method' style='display: none;'><a href="Point.html#.padRight">padRight</a></li><li data-type='method' style='display: none;'><a href="Point.html#.product">product</a></li><li data-type='method' style='display: none;'><a href="Point.html#add">add</a></li><li data-type='method' style='display: none;'><a href="Point.html#addCoordinate">addCoordinate</a></li><li data-type='method' style='display: none;'><a href="Point.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="Point.html#dimensions">dimensions</a></li><li data-type='method' style='display: none;'><a href="Point.html#project">project</a></li><li data-type='method' style='display: none;'><a href="Point.html#scale">scale</a></li><li data-type='method' style='display: none;'><a href="Point.html#subtract">subtract</a></li></ul></li><li><a href="PolytopeC.html">PolytopeC</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PolytopeC.html#faceToVertices">faceToVertices</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#gravicenter">gravicenter</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#recenter">recenter</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#scale">scale</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#setSpaceDimensions">setSpaceDimensions</a></li><li data-type='method' style='display: none;'><a href="PolytopeC.html#toPolytopeC">toPolytopeC</a></li></ul></li><li><a href="Scene.html">Scene</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Scene.html#add">add</a></li></ul></li><li><a href="SweeplineEdge.html">SweeplineEdge</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SweeplineEdge.html#getId">getId</a></li><li data-type='method' style='display: none;'><a href="SweeplineEdge.html#rightVertex">rightVertex</a></li><li data-type='method' style='display: none;'><a href="SweeplineEdge.html#updateRedirectTable">updateRedirectTable</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="BalanceState.html">BalanceState</a></li><li><a href="ConstructionNodeType.html">ConstructionNodeType</a></li><li><a href="Space.html">Space</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Space.html#.area">area</a></li><li data-type='method' style='display: none;'><a href="Space.html#.distance">distance</a></li><li data-type='method' style='display: none;'><a href="Space.html#.distanceSq">distanceSq</a></li><li data-type='method' style='display: none;'><a href="Space.html#.intersect">intersect</a></li><li data-type='method' style='display: none;'><a href="Space.html#.sameSlope">sameSlope</a></li></ul></li><li><a href="Translation.html">Translation</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Translation.html#.addAdjective">addAdjective</a></li><li data-type='method' style='display: none;'><a href="Translation.html#.elementName">elementName</a></li><li data-type='method' style='display: none;'><a href="Translation.html#.greekPrefix">greekPrefix</a></li></ul></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-dependencies.html">How to update Miratope's dependencies?</a></li><li><a href="tutorial-translation_.html">How to translate Miratope?</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BalanceState%255Bundefined%255D">BalanceState[undefined]</a></li><li><a href="global.html#CNType%255Bundefined%255D">CNType[undefined]</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">polytopes/classes/polytopeBuild.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolytopeBuild = void 0;
const constructionNode_1 = require("../../data structures/constructionNode");
const group_1 = require("../../data structures/group");
const point_1 = require("../../geometry/point");
const polytopeTypes_1 = require("../polytopeTypes");
class PolytopeBuild {
    /**
     * Simple auxiliary function to get the length of a regular polygon's vertex figure.
     * @param {number} n The number of sides of the polygon.
     * @param {number} d The winding number of the polygon.
     */
    static verfLength(n, d) {
        if (d === undefined)
            d = 1;
        return 2 * Math.cos(Math.PI / (n / d));
    }
    /**
     * Creates the null polytope.
     * @returns {Polytope} An instance of the null polytope.
     */
    static nullitope() {
        return new polytopeTypes_1.PolytopeC([], new constructionNode_1.CNCodename("nullitope"));
    }
    /**
     * Creates the point polytope.
     * @returns An instance of the point polytope.
     */
    static point() {
        return new polytopeTypes_1.PolytopeC([[new point_1.Point([])]], new constructionNode_1.CNCodename("point"));
    }
    /**
     * Creates a dyad (line segment) of a specified length.
     * @param {number} length The length of the dyad.
     * @returns A dyad of the specified length.
     */
    static dyad(length) {
        //The dyad's length defaults to 1.
        //Note that the variable name length is actually a misnomer, and will store half of the length instead.
        if (length === undefined)
            length = 0.5;
        else
            length /= 2;
        return new polytopeTypes_1.PolytopeC([[new point_1.Point([-length]), new point_1.Point([length])], [[0, 1]]], new constructionNode_1.CNCodename("dyad"));
    }
    //Builds a polygon from the vertices given in order.
    static polygon(points) {
        const newElementList = [[], [], [[]]];
        let i;
        for (i = 0; i &lt; points.length - 1; i++) {
            newElementList[0].push(points[i]);
            newElementList[1].push([i, i + 1]);
            newElementList[2][0].push(i);
        }
        newElementList[0].push(points[i]);
        newElementList[1].push([i, 0]);
        newElementList[2][0].push(i);
        return new polytopeTypes_1.PolytopeC(newElementList, new constructionNode_1.CNPolygon([points.length, 1]));
    }
    /**
     * Builds a regular polygon with a given edge length.
     * @param {number} n The number of sides of the regular polygon.
     * @param {number} d The winding number of the regluar polygon.
     * @param {number} [s=1] The edge length of the regular polygon.
     * @returns {Polytope} The regular polygon.
     */
    static regularPolygon(n, d, s) {
        let gcd;
        if (d === undefined) {
            d = 1;
            gcd = 1;
        }
        else
            gcd = Math.gcd(n, d);
        if (s === undefined)
            s = 1;
        const els = [[], [], []];
        const n_gcd = n / gcd;
        let counter = 0;
        let components;
        let x = 0, y = d;
        const t = 2 * Math.PI / n;
        let angle = 0;
        const invRad = 2 * Math.sin(Math.PI * d / n) / s; //1 / the circumradius.
        for (let i = 0; i &lt; n; i++) {
            els[0].push(new point_1.Point([Math.cos(angle) / invRad, Math.sin(angle) / invRad])); //Vertices
            angle += t;
        }
        //i is the component number.
        for (let i = 0; i &lt; gcd; i++) {
            //x and y keep track of the vertices that are being connected.
            components = [];
            //j is the edge.
            for (let j = 0; j &lt; n_gcd; j++) {
                els[1].push([x, y]); //Edges
                x = y;
                y += d;
                if (y >= n)
                    y -= n;
                components.push(counter++); //Components
            }
            els[2].push(components);
            x++;
            y++;
        }
        return new polytopeTypes_1.PolytopeC(els, new constructionNode_1.CNPolygon([n, d]));
    }
    //Builds a Grünbaumian n/d star with edge lenth s.
    //In the future, should be replaced by the PolytopeS version.
    static regularPolygonG(n, d, s) {
        if (d === undefined)
            d = 1;
        if (s === undefined)
            s = 1;
        const els = [[], [], [[]]];
        let angle = 0;
        const t = Math.PI * d / n;
        const invRad = 2 * Math.sin(t) / s; //1 / the circumradius
        for (let i = 0; i &lt; n; i++) {
            els[0].push(new point_1.Point([Math.cos(angle) / invRad, Math.sin(angle) / invRad])); //Vertices
            els[2][0].push(i); //Face.
            angle += 2 * t;
        }
        for (let i = 0; i &lt; n - 1; i++)
            els[1].push([i, i + 1]); //Edges
        els[1].push([els[0].length - 1, 0]);
        return new polytopeTypes_1.PolytopeC(els, new constructionNode_1.CNPolygon([n, d]));
    }
    /**
     * Builds a semiuniform polygon with `n` sides and "absolute turning number" `d`
     * with some given edge lengths.
     * The absolute turning number is the number `d` such that
     * the sum of the angles of the polygon is `π(n - 2d)`.
     * The bowtie is generated by the special case of `n = 4`, `d = 0`, for lack of
     * better parameters.
     * @param {number} n The number of sides of the semiuniform polygon.
     * @param {number} [d=1] The "absolute turning number", as defined above.
     * @param {number} [a=1] The first edge length of the polygon.
     * @param {number} [b=1] The second edge length of the polygon.
     * @return {Polytope} The resulting semiregular polygon.
     */
    static semiregularPolygon(n, d = 1, a = 1, b = 1) {
        //If n = 4, d = 0, a bowtie is created.
        //Idk if there are more natural parameters for the bowtie.
        if (n === 4 &amp;&amp; d === 0) {
            //If a > b, swaps b and a.
            if (a > b) {
                const t = a;
                a = b;
                b = t;
            }
            b = Math.sqrt(b * b - a * a) / 2;
            a /= 2;
            return new polytopeTypes_1.PolytopeC([
                [new point_1.Point([-a, b]), new point_1.Point([a, b]), new point_1.Point([-a, -b]), new point_1.Point([a, -b])],
                [[0, 1], [1, 2], [2, 3], [3, 0]],
                [[0, 1, 2, 3]]
            ], new constructionNode_1.CNCodename("bowtie"));
        }
        //The angles and sides of a triangle made by three adjacent vertices.
        //Also, the circumdiameter 2R.
        const gamma = Math.PI * (1 - 2 * d / n);
        const c = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(gamma));
        const R = c / Math.sin(gamma) / 2;
        //The sine rule doesn't work here, since asin is ambiguous in [0, π/2].
        //Instead, we use the more complicated cosine rule.
        const alpha = 2 * Math.acos((b * b + c * c - a * a) / (2 * b * c)); //is actually 2α.
        const beta = 2 * Math.acos((a * a + c * c - b * b) / (2 * a * c)); //is actually 2β.
        let angle = 0;
        const els = [[], [], [[]]];
        for (let i = 0; i &lt; n / 2; i++) {
            //Side a.
            els[0].push(new point_1.Point([Math.cos(angle) * R, Math.sin(angle) * R])); //Vertices
            els[2][0].push(2 * i); //Face.
            angle += alpha;
            //Side b
            els[0].push(new point_1.Point([Math.cos(angle) * R, Math.sin(angle) * R])); //Vertices
            els[2][0].push(2 * i + 1); //Face.
            angle += beta;
        }
        for (let i = 0; i &lt; n - 1; i++)
            els[1].push([i, i + 1]); //Edges
        els[1].push([els[0].length - 1, 0]);
        return new polytopeTypes_1.PolytopeC(els, new constructionNode_1.CNPolygon([n, d]));
    }
    //Builds a hypercube in the specified amount of dimensions.
    //Positioned in the standard orientation with edge length 1.
    //In the future, will be replaced by the PolytopeS version.
    static hypercube(dimensions) {
        const symmetries = group_1.ConcreteGroup.BC(dimensions);
        const flagClasses = [];
        for (let i = 0; i &lt; dimensions; i++)
            flagClasses.push([[0, [i]]]);
        const coordinates = [];
        for (let i = 0; i &lt; dimensions; i++)
            coordinates.push(0.5);
        const vertices = [new point_1.Point(coordinates)];
        return new polytopeTypes_1.PolytopeS(symmetries, flagClasses, vertices, dimensions);
    }
    //Builds a simplex in the specified amount of dimensions.
    //Implements the more complicated coordinates in the space of the same dimension.
    //In the future, will be replaced by the PolytopeS version.
    static simplex(dimensions) {
        const vertices = [];
        //Memoizes some square roots, tiny optimization.
        const aux = [Infinity];
        for (let i = 1; i &lt;= dimensions; i++)
            aux.push(1 / Math.sqrt(2 * i * (i + 1)));
        //Adds vertices.
        for (let i = 0; i &lt;= dimensions; i++) {
            const coordinates = [];
            for (let j = 1; j &lt;= dimensions; j++) {
                if (j > i)
                    coordinates.push(-aux[j]);
                else if (j === i)
                    coordinates.push(j * aux[j]);
                else
                    coordinates.push(0);
            }
            vertices.push(new point_1.Point(coordinates));
        }
        //Adds higher dimensional elements.
        const els = [vertices];
        for (let i = 1; i &lt;= dimensions; i++)
            els.push([]);
        const locations = [];
        for (let i = 0; i &lt; dimensions + 1; i++)
            locations[Math.pow(2, i)] = i;
        for (let i = 1; i &lt; Math.pow(2, dimensions + 1); i++) {
            //Vertices were generated earlier
            if (!(i &amp; (i - 1)))
                continue;
            let elementDimension = -1;
            let t = i;
            const elemVertices = [];
            do {
                elementDimension++;
                elemVertices.push(t &amp; ~(t - 1));
                t = t &amp; (t - 1);
            } while (t > 0);
            const facets = [];
            for (let k = 0; k &lt; elemVertices.length; k++)
                facets.push(locations[i ^ elemVertices[k]]);
            locations[i] = els[elementDimension].length;
            els[elementDimension].push(facets);
        }
        return new polytopeTypes_1.PolytopeC(els, new constructionNode_1.CNSimplex(dimensions));
    }
    //Builds a cross-polytope in the specified amount of dimensions.
    //Positioned in the standard orientation with edge length 1.
    //In the future, will be replaced by the PolytopeS version.
    static cross(dimensions) {
        const symmetries = group_1.ConcreteGroup.BC(dimensions);
        const flagClasses = [];
        for (let i = 0; i &lt; dimensions; i++)
            flagClasses.push([[0, [dimensions - (i + 1)]]]);
        const coordinates = [];
        for (let i = 1; i &lt; dimensions; i++)
            coordinates.push(0);
        coordinates.push(Math.SQRT1_2);
        const vertices = [new point_1.Point(coordinates)];
        return new polytopeTypes_1.PolytopeS(symmetries, flagClasses, vertices, dimensions);
    }
    //Generates a rectified orthoplex as a PolytopeS.
    //Will probably get replaced once more general methods for generating from CDs are added.
    static recticross(dimensions) {
        const flagClasses = [];
        for (let i = 0; i &lt; dimensions; i++) {
            const row = [];
            //i is change, j is flagclass
            for (let j = 0; j &lt; dimensions - 1; j++) {
                if (j >= i)
                    row.push([j, [dimensions - (i + 2)]]);
                else if (j == 0 &amp;&amp; i == 1)
                    row.push([0, [dimensions - 1]]);
                else if (i == j + 1)
                    row.push([j - 1, []]);
                else if (i == j + 2)
                    row.push([j + 1, []]);
                else
                    row.push([j, [dimensions - (i + 1)]]);
            }
            flagClasses.push(row);
        }
        const coordinates = [];
        for (let i = 2; i &lt; dimensions; i++)
            coordinates.push(0);
        coordinates.push(Math.SQRT1_2);
        coordinates.push(Math.SQRT1_2);
        const vertices = [new point_1.Point(coordinates)];
        return new polytopeTypes_1.PolytopeS(group_1.ConcreteGroup.BC(dimensions), flagClasses, vertices, dimensions);
    }
    //Creates a uniform {n / d} antiprism.
    //Only meant for when (n, d) = 1.
    static uniformAntiprism(n, d) {
        if (d === undefined)
            d = 1;
        const x = n / d, scale = 2 * Math.sin(Math.PI / x), //Guarantees an unit edge length polytope.
        height = Math.sqrt((Math.cos(Math.PI / x) - Math.cos(2 * Math.PI / x)) / 2) / scale; //Half of the distance between bases.
        const base1 = [], base2 = [], newElementList = [[], [], [base1, base2], [[]]];
        let i = 0; //The edges in the bases.
        while (i &lt; 2 * (n - 1)) {
            //Vertices.
            newElementList[0].push(new point_1.Point([Math.cos(Math.PI * (i / x)) / scale, Math.sin(Math.PI * (i / x)) / scale, height]));
            //Equatorial edges, top &amp; bottom edges.
            newElementList[1].push([i, i + 1], [i, i + 2]);
            //Triangular faces.
            newElementList[2].push([2 * i, 2 * i + 1, 2 * i + 2]);
            //Polygonal faces.
            base1.push(2 * i + 1);
            i++;
            //Same thing down here:
            newElementList[0].push(new point_1.Point([Math.cos(Math.PI * (i / x)) / scale, Math.sin(Math.PI * (i / x)) / scale, -height]));
            newElementList[1].push([i, i + 1]);
            newElementList[1].push([i, i + 2]);
            newElementList[2].push([2 * i, 2 * i + 1, 2 * i + 2]);
            base2.push(2 * i + 1);
            i++;
        }
        //Adds last elements.
        newElementList[0].push(new point_1.Point([Math.cos(Math.PI * (i / x)) / scale, Math.sin(Math.PI * (i / x)) / scale, height]));
        newElementList[1].push([i, i + 1]);
        newElementList[1].push([i, 0]);
        newElementList[2].push([2 * i, 2 * i + 1, 2 * i + 2]);
        base1.push(2 * i + 1);
        i++;
        newElementList[0].push(new point_1.Point([Math.cos(Math.PI * (i / x)) / scale, Math.sin(Math.PI * (i / x)) / scale, -height]));
        newElementList[1].push([i, 0], [i, 1]);
        newElementList[2].push([2 * i, 2 * i + 1, 0]);
        base2.push(2 * i + 1);
        //Adds component.
        for (i = 0; i &lt; 2 * (n + 1); i++)
            newElementList[3][0].push(i);
        //We call PolytopeBuild.regularPolygon(n, d).construction instead of instanciating the CNPolygon directly
        //so that the ConstructionNode has an associated polytope.
        return new polytopeTypes_1.PolytopeC(newElementList, new constructionNode_1.CNAntiprism(PolytopeBuild.regularPolygon(n, d).construction));
    }
    //Creates an {n / d} cupola with regular faces.
    static cupola(n, d) {
        if (d === undefined)
            d = 1;
        const x = n / d, r1 = 1 / (2 * Math.sin(Math.PI / x)), //Radius of the smaller base.
        r2 = 1 / (2 * Math.sin(Math.PI / (2 * x))), //Radius of the larger base.
        t = 1 / (2 * Math.tan(Math.PI / x)) - 1 / (2 * Math.tan(Math.PI / (2 * x))), //Temporary variable.
        h0 = Math.sqrt(1 - t * t), //Distance between bases.
        h1 = ((r2 * r2 - r1 * r1) / h0 + h0) / 2, //Distance between circumcenter and smaller base.
        h2 = h1 - h0; //Distance between circumcenter and larger base.
        const base1 = [], base2 = [], newElementList = [[], [], [base1, base2], [[]]]; //List of elements of the cupola.
        let i;
        for (i = 0; i &lt; n - 1; i++) {
            //Small base's vertices.
            newElementList[0].push(new point_1.Point([r1 * Math.cos(2 * Math.PI * (i / x)), r1 * Math.sin(2 * Math.PI * (i / x)), h1]));
            //Small base's edges.
            newElementList[1].push([i, i + 1]);
            //Connecting edges.
            newElementList[1].push([i, n + 2 * i]);
            newElementList[1].push([i, n + 2 * i + 1]);
            //Triangles.
            newElementList[2].push([3 * i + 1, 3 * i + 2, 3 * n + 2 * i]);
            //Squares.
            newElementList[2].push([3 * i + 2, 3 * n + 2 * i + 1, 3 * i + 4, 3 * i]);
            //Small base.
            base1.push(3 * i);
        }
        //Adds last elements.
        newElementList[0].push(new point_1.Point([r1 * Math.cos(2 * Math.PI * (i / x)), r1 * Math.sin(2 * Math.PI * (i / x)), h1]));
        newElementList[1].push([i, 0]);
        newElementList[1].push([i, n + 2 * i]);
        newElementList[1].push([i, n + 2 * i + 1]);
        newElementList[2].push([3 * i + 1, 3 * i + 2, 3 * n + 2 * i]);
        newElementList[2].push([3 * i + 2, 3 * n + 2 * i + 1, 1, 3 * i]);
        base1.push(3 * i);
        for (i = 0; i &lt; 2 * n - 1; i++) {
            //Big base's vertices.
            newElementList[0].push(new point_1.Point([r2 * Math.cos(Math.PI * ((i - 0.5) / x)), r2 * Math.sin(Math.PI * ((i - 0.5) / x)), h2]));
            //Big base's edges.
            newElementList[1].push([n + i, n + i + 1]);
            //Big base.
            base2.push(3 * n + i);
        }
        //Adds last elements.
        newElementList[0].push(new point_1.Point([r2 * Math.cos(Math.PI * ((i - 0.5) / x)), r2 * Math.sin(Math.PI * ((i - 0.5) / x)), h2]));
        newElementList[1].push([n + i, n]);
        base2.push(3 * n + i);
        for (i = 0; i &lt; 2 * n + 2; i++)
            newElementList[3][0].push(i);
        //We call PolytopeBuild.regularPolygon(n, d).construction instead of instanciating the CNPolygon directly
        //so that the ConstructionNode has an associated polytope.
        return new polytopeTypes_1.PolytopeC(newElementList, new constructionNode_1.CNCupola(PolytopeBuild.regularPolygon(n, d).construction));
    }
    //Creates an {n / d} cuploid with regular faces.
    static cuploid(n, d) {
        if (d === undefined)
            d = 1;
        const x = n / d, r1 = 1 / (2 * Math.sin(Math.PI / x)), //Radius of the smaller base.
        r2 = 1 / (2 * Math.sin(Math.PI / (2 * x))), //Radius of the larger base.
        t = 1 / (2 * Math.tan(Math.PI / x)) - 1 / (2 * Math.tan(Math.PI / (2 * x))), //Temporary variable.
        h0 = Math.sqrt(1 - t * t), //Distance between bases.
        h1 = ((r2 * r2 - r1 * r1) / h0 + h0) / 2, //Distance between circumcenter and smaller base.
        h2 = h1 - h0; //Distance between circumcenter and larger base.
        const base = [], newElementList = [[], [], [base], [[]]]; //List of elements of the cupola.
        let i;
        for (i = 0; i &lt; n - 1; i++) {
            //Small base's vertices.
            newElementList[0].push(new point_1.Point([r1 * Math.cos(2 * Math.PI * (i / x)), r1 * Math.sin(2 * Math.PI * (i / x)), h1]));
            //Small base's edges.
            newElementList[1].push([i, i + 1]);
            //Connecting edges.
            newElementList[1].push([i, n + (2 * i) % n]);
            newElementList[1].push([i, n + (2 * i + 1) % n]);
            //Triangles.
            newElementList[2].push([3 * i + 1, 3 * i + 2, 3 * n + (2 * i) % n]);
            //Squares.
            newElementList[2].push([3 * i + 2, 3 * n + (2 * i + 1) % n, 3 * i + 4, 3 * i]);
            //Small base.
            base.push(3 * i);
        }
        //Adds last elements.
        newElementList[0].push(new point_1.Point([r1 * Math.cos(2 * Math.PI * (i / x)), r1 * Math.sin(2 * Math.PI * (i / x)), h1]));
        newElementList[1].push([i, 0]);
        newElementList[1].push([i, 2 * i]);
        newElementList[1].push([i, 2 * i + 1]);
        newElementList[2].push([3 * i + 1, 3 * i + 2, 2 * n + 2 * i]);
        newElementList[2].push([3 * i + 2, 2 * n + 2 * i + 1, 1, 3 * i]);
        base.push(3 * i);
        for (i = 0; i &lt; n - 1; i++) {
            //Big base's vertices.
            newElementList[0].push(new point_1.Point([r2 * Math.cos(Math.PI * ((i - 0.5) / x)), r2 * Math.sin(Math.PI * ((i - 0.5) / x)), h2]));
            //Big base's edges.
            newElementList[1].push([n + i, n + i + 1]);
        }
        //Adds last elements.
        newElementList[0].push(new point_1.Point([r2 * Math.cos(Math.PI * ((i - 0.5) / x)), r2 * Math.sin(Math.PI * ((i - 0.5) / x)), h2]));
        newElementList[1].push([n + i, n]);
        for (i = 0; i &lt; 2 * n + 1; i++)
            newElementList[3][0].push(i);
        //We call PolytopeBuild.regularPolygon(n, d).construction instead of instanciating the CNPolygon directly
        //so that the ConstructionNode has an associated polytope.
        return new polytopeTypes_1.PolytopeC(newElementList, new constructionNode_1.CNCuploid(PolytopeBuild.regularPolygon(n, d).construction));
    }
    //Creates an {n / d} cupolaic blend with regular faces.
    static cupolaicBlend(n, d) {
        if (d === undefined)
            d = 1;
        const x = n / d, r1 = 1 / (2 * Math.sin(Math.PI / x)), //Radius of the smaller base.
        r2 = 1 / (2 * Math.sin(Math.PI / (2 * x))), //Radius of the larger base.
        t = 1 / (2 * Math.tan(Math.PI / x)) - 1 / (2 * Math.tan(Math.PI / (2 * x))), //Temporary variable.
        h0 = Math.sqrt(1 - t * t), //Distance between bases.
        h1 = ((r2 * r2 - r1 * r1) / h0 + h0) / 2, //Distance between circumcenter and smaller base.
        h2 = h1 - h0; //Distance between circumcenter and larger base.
        const base1 = [], base2 = [], newElementList = [[], [], [base1, base2], [[]]]; //List of elements of the cupola.
        let even = true;
        let i;
        for (i = 0; i &lt; 2 * (n - 1); i++) {
            //Small bases' vertices.
            newElementList[0].push(new point_1.Point([r1 * Math.cos(Math.PI * (i / x)), r1 * Math.sin(Math.PI * (i / x)), h1]));
            //Small bases' edges.
            newElementList[1].push([i, i + 2]);
            //Connecting edges.
            newElementList[1].push([i, 2 * n + i]);
            newElementList[1].push([i, 2 * n + i + 1]);
            //Triangles.
            newElementList[2].push([3 * i + 1, 3 * i + 2, 6 * n + i]);
            //Squares.
            newElementList[2].push([3 * i + 2, 6 * n + i + 1, 3 * i + 7, 3 * i]);
            //Small base.
            if (even)
                base1.push(3 * i);
            else
                base2.push(3 * i);
            even = !even;
        }
        //Adds last elements.
        newElementList[0].push(new point_1.Point([r1 * Math.cos(Math.PI * (i / x)), r1 * Math.sin(Math.PI * (i / x)), h1]));
        newElementList[1].push([i, 0]);
        newElementList[1].push([i, 2 * n + i]);
        newElementList[1].push([i, 2 * n + i + 1]);
        newElementList[2].push([3 * i + 1, 3 * i + 2, 6 * n + i]);
        newElementList[2].push([3 * i + 2, 6 * n + i + 1, 1, 3 * i]);
        base1.push(3 * i);
        i++;
        newElementList[0].push(new point_1.Point([r1 * Math.cos(Math.PI * (i / x)), r1 * Math.sin(Math.PI * (i / x)), h1]));
        newElementList[1].push([i, 1]);
        newElementList[1].push([i, 2 * n + i]);
        newElementList[1].push([i, 2 * n]);
        newElementList[2].push([3 * i + 1, 3 * i + 2, 6 * n + i]);
        newElementList[2].push([3 * i + 2, 6 * n, 4, 3 * i]);
        base2.push(3 * i);
        for (i = 0; i &lt; 2 * n - 1; i++) {
            //Big base's vertices.
            newElementList[0].push(new point_1.Point([r2 * Math.cos(Math.PI * ((i - 0.5) / x)), r2 * Math.sin(Math.PI * ((i - 0.5) / x)), h2]));
            //Big base's edges.
            newElementList[1].push([2 * n + i, 2 * n + i + 1]);
        }
        //Adds last elements.
        newElementList[0].push(new point_1.Point([r2 * Math.cos(Math.PI * ((i - 0.5) / x)), r2 * Math.sin(Math.PI * ((i - 0.5) / x)), h2]));
        newElementList[1].push([2 * n + i, 2 * n]);
        for (i = 0; i &lt; 2 * n + 1; i++)
            newElementList[3][0].push(i);
        //We call PolytopeBuild.regularPolygon(n, d).construction instead of instanciating the CNPolygon directly
        //so that the ConstructionNode has an associated polytope.
        return new polytopeTypes_1.PolytopeC(newElementList, new constructionNode_1.CNCupolaicBlend(PolytopeBuild.regularPolygon(n, d).construction));
    }
}
exports.PolytopeBuild = PolytopeBuild;
//Extrudes a polytope to a pyramid with an apex at the specified point.
//Constructs pyramids out of elements recursively.
//The ith n-element in the original polytope gets extruded to the
//(i+[(n+1)-elements in the original polytope])th element in the new polytope.
/*
    //Generates the petrie dual of a polytope
    petrial(): Polytope{
        gNodes = this.polytopeToGraph();
        var faces = [];
        var edges = [];
        var edgeCount = [];
        for(var f = 0; f &lt; this.elementList[2].length; f++) {
            adjVerts = this.adjacentEls(2, f, 2);
            build_faces:
            for(sVert in adjVerts) {
                var nVert = undefined
                while(nVert != sVert) {
                    //Oh god, this one definition relies on so many things being in sync
                    nEdge = [this.elementList[0].indexOf(sVert), gNodes[this.elementList[0].indexOf(sVert)].neighbors[0].value];
                    //newEdge is an array of the indexes of the points that make up the new edge: [a, b]
                    switch(edgeCount[nEdge.toString()]) {
                        case undefined:
                            edgeCount[nEdge.toString()] = 1;
                            edges.push(nEdge);
                            break;
                        case 1:
                            edgeCount[nEdge.toString()] = 2;
                            break;
                        case 2:
                            break build_faces;
                    };
                    nVert = nEdge[1];
                    //Select nEdge's adjacent face
                    //Set f to the index of newEdge's adjacent face
                }

            }
        }
    };
    */
/**
     * Returns the subelements that are adjacent to an element of elementList d layers down.
     * @param {number} type The index of the type of element in newElementList.
     * @param {number} elem The index of the element selected.
     * @param {number} d The subelement type (type-d) you want from elem.
     * @returns {Point | number[]} The adjacent subelements in an array.
     * @todo Check the typing (I don't trust that I did it correctly -- URL).
     */
/*adjacentEls(type: number, elem: number, d: number): Point | number[] {
        let down = 1;
        let P = this.toPolytopeC();
        let subels = P.elementList[type][elem];
        let subelsTemp: Point | number[] = [];
        while(down &lt; d) {
            down++;
            for(let i in subels)
                subelsTemp = [...new Set(subelsTemp.concat(P.elementList[type - 1][i]))];
            subels = subelsTemp;
            type--;
        }
        return subels;
    };


*/
//Builds a n/d star with edge length s.
//If n and d are not coprime, a regular polygon compound is made instead.
//In the future, should be replaced by the PolytopeS version.
/*
    //Returns if two elements of the same type are adjacent
    //TODO: maybe adjust this so it works for elements of different types too?
    Polytope.checkAdjacent = function(otherelement) {
        return this.some(item => otherelement.includes(item));
    }
    */
/**
 * Extrudes a polytope into a pyramid.
 * @param	{(Point|number)} apex The apex of the pyramid, or its height.
 * @returns {Polytope} The resulting pyramid.
 */
polytopeTypes_1.PolytopeB.prototype.extrudeToPyramid = function (apex) {
    const P = this.toPolytopeC();
    if (!P.elementList[0])
        return new polytopeTypes_1.PolytopeC([[new point_1.Point([])]]);
    let els, i;
    //If the height was passed instead, builds a point from there.
    if (typeof apex === 'number') {
        const newApex = [];
        for (let i = 0; i &lt; P.dimensions; i++)
            newApex.push(0);
        newApex.push(apex);
        apex = new point_1.Point(newApex);
    }
    P.dimensions++;
    P.elementList.push([]);
    const oldElNumbers = [];
    for (i = 0; i &lt;= P.dimensions; i++)
        oldElNumbers.push(P.elementList[i].length);
    //Adds apex.
    P.elementList[0].push(apex);
    P.setSpaceDimensions(Math.max(apex.dimensions(), P.spaceDimensions));
    //Adds edges.
    if (P.elementList[1]) {
        for (i = 0; i &lt; oldElNumbers[0]; i++)
            P.elementList[1].push([i, oldElNumbers[0]]);
    }
    //Adds remaining elements.
    for (let d = 2; d &lt;= P.dimensions; d++) {
        for (i = 0; i &lt; oldElNumbers[d - 1]; i++) {
            els = [i];
            for (let j = 0; j &lt; P.elementList[d - 1][i].length; j++)
                els.push(P.elementList[d - 1][i][j] + oldElNumbers[d - 1]);
            P.elementList[d].push(els);
        }
    }
    const construction = new constructionNode_1.CNPyramid(P.construction);
    P.setConstruction(construction);
    return P;
};
//# sourceMappingURL=polytopeBuild.js.map</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Fri Dec 25 2020 17:40:45 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
