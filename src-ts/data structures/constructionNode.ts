import { Translation } from "../translation/translation";

/**
 * An object containing the possible types of {@link ConstructionNode|ConstructionNodes}.
 * @enum {number}
 * @namespace ConstructionNodeType
 */
export enum CNType {
	/**
	 * The corresponding ConstructionNode has two children `[n, d]`,
	 * representing the number of facets `n`
	 * and the number of dimensions `d` of the polytope.
	 * Its name is generated by {@linkcode Translation.plain}.
	 */
	Plain,

	/**
	 * The corresponding ConstructionNode has two children `[n, d]`, representing
	 * the regular polygon {`n`/`d`}.
	 * Its name is generated by {@linkcode Translation.regularPolygonName}.
	 */
	Polygon,

	/**
	 * The corresponding ConstructionNode has an array with the factors of a prism
	 * product as children.
	 * Its name is generated by {@linkcode Translation.multiFamily}.
	 */
	Multiprism,

	/**
	 * The corresponding ConstructionNode has an array with the factors of a tegum
	 * product as children.
	 * Its name is generated by {@linkcode Translation.multiFamily}.
	 */
	Multitegum,

	/**
	 * The corresponding ConstructionNode has an array with the factors of a
	 * pyramid product as children.
	 * Its name is generated by {@linkcode Translation.multiFamily}.
	 */
	Multipyramid,

	/**
	 * The corresponding ConstructionNode has a single child representing the
	 * antiprismatic base
	 * Its name is generated by {@linkcode Translation.familyMember}.
	 */
	Antiprism,

	/**
	 * The corresponding ConstructionNode has a single child representing the
	 * pyramidal base.
	 * Its name is generated by {@linkcode Translation.familyMember}.
	 */
	Pyramid,

	/**
	 * The corresponding ConstructionNode has a single child representing the
	 * cupoidal base.
	 * Its name is generated by {@linkcode Translation.familyMember}.
	 */
	Cupola,

	/**
	 * The corresponding ConstructionNode has a single child representing the
	 * cuploidal base.
	 * Its name is generated by {@linkcode Translation.familyMember}.
	 */
	Cuploid,

	/**
   * The corresponding ConstructionNode has a single child representing the
	 * cupolaic blend base.
	 * Its name is generated by {@linkcode Translation.familyMember}.
	 */
	CupolaicBlend,

	/**
	 * The corresponding ConstructionNode has a polytope's "code name" as a child.
	 * Used for polytopes whose names are in loadMessages.js.
	 * Can be translated.
	 * Its name is generated by {@linkcode Translation.get}.
	 */
	Codename,

	/**
	 * The corresponding ConstructionNode has a polytope's name as a child.
	 * The default for imported polytopes,
	 * or polytopes not built out of anything else whose name is known.
	 * Can **not** be translated.
	 * Its name is just the ConstructionNode's child itslf.
	 */
	Name,

	/**
	 * The corresponding ConstructionNode has the dimension of a hypercube as a
	 * child.
	 * Its name is generated by {@linkcode Translation.hypercube}.
	 */
	Hypercube,

	/**
	 * The corresponding ConstructionNode has the dimension of a simplex as a
	 * child.
	 * Its name is generated by {@linkcode Translation.simplex}.
	 */
	Simplex,

	/**
	 * The corresponding ConstructionNode has the dimension of an orthoplex as a
	 * child.
	 * Its name is generated by {@linkcode Translation.cross}.
	 */
	Cross
};

export abstract class ConstructionNode<T> {
	abstract readonly type: CNType
	abstract child: T;
	abstract polytope: Object | undefined;
	abstract gender: string = "";

	abstract getName(): string;

	//Assigns its own gender to its children.
	abstract setGenders(gender: string): void;

	/**
	 * A multiprism of multiprisms is just a larger multiprism,
	 * a multitegum of multitegums is just a larger multitegum, etc.
	 * This function removes children nodes of the same type
	 * and replaces them by their children.
	 * @private
	 */
	mergeChildren() {
		let childrenArray: ConstructionNode<any>[] = this.child as unknown as ConstructionNode<any>[];

		if(childrenArray.length) {
			var oldLength = childrenArray.length;
			for(let i = 0; i < oldLength; i++) {
				if(childrenArray[i].type === this.type) {
					for(let j = 0; j < childrenArray[i].child.length - 1; j++)
						childrenArray.push(childrenArray[i].child.pop());
					childrenArray[i] = childrenArray[i].child.pop();
				}
			}
		}
		else
			throw new Error("_mergeChildren can only be called in a product ConstructionNode!");
	};

	//Converts a nodeC into its the corresponding member of the specified family's name.
  static familyMember(node: ConstructionNode<any>, family: string, gender: string) {
  	return Translation.addAdjective(
  		Translation.toAdjective(node.getName(), gender),
  		Translation.get(family)
  	);
  };

  //Converts a set of ConstructionNodes into their prism product/tegum product/pyramid product's name.
  //The family is which product is used ("prism", "tegum", "pyramid").
  //specialFactor is an element that, when in the product, is considered differently.
  //specialFactorModify specifies what this element becomes into within the product.
  //e.g. for a multiprism, specialFactor = "dyad", specialFactorModify = "prism".
  //For a multipyramid, specialFactor = "point", specialFactorModify = "pyramid".
  static multiFamily(nodes: ConstructionNode<any>[], family: string, specialFactor: string, specialFactorModify: string, gender: string) {
  	let names: string[] = [];
  	const FAMILY = Translation.get(family),
  	FAMILYADJ = Translation.toAdjective(FAMILY, gender),
  	SPECIAL = Translation.get(specialFactor),
  	SPECIALMOD = Translation.get(specialFactorModify),
  	SPECIALMODADJ = Translation.toAdjective(SPECIALMOD, gender);
  	let specialCount = 0,
  	tempName: string, concatName: string, allNamesSame = true;

  	//Counts special factors.
  	for(let i = 0; i < nodes.length; i++) {
  		tempName = nodes[i].getName();
  		if(tempName === SPECIAL)
  			specialCount++;
  		else
  			names.push(tempName);
  	}

  	let prefix: string; //The prefix before [family], e.g. *duo*[family], *trio*[family], ...
  	switch(names.length) {
  		//All special factors.
  		case 0:
  			names.push(SPECIAL);
  			specialCount--;
  			/*prefix = ""; //Fun fact: this code works the same
  			break; //without these two lines!*/
  		case 1:
  			prefix = ""; break;
  		case 2:
  			prefix = "duo"; break;
  		case 3:
  			prefix = "trio"; break;
  		default:
  			prefix = Translation.greekPrefix(names.length);	break;
  	}

    //names cannot be empty.
  	tempName = names.pop() as string;
  	concatName = Translation.toAdjective(tempName, gender);

  	while(names.length > 0) {
  		concatName += "-" + Translation.toAdjective(names[names.length - 1], gender);
  		if(names.pop() !== tempName)
  			allNamesSame = false;
  	}

  	if(!specialCount) {
  		//X multi[family]
  		if(allNamesSame)
  			return Translation.addAdjective(
  				Translation.toAdjective(tempName, gender),
  				prefix + FAMILY
  			);

  		//X-Y-Z multi[family]
  		return Translation.addAdjective(
  			concatName,
  			prefix + FAMILY
  		);
  	}

  	//Same as before, but adds as many ...[family-adj] [family]	as needed at the end.
  	if(allNamesSame)
  		concatName = Translation.toAdjective(tempName, gender);

  	//We aren't calling a single polytope X an "X mono[family]", are we?
  	if(prefix)
  		concatName = Translation.addAdjective(
  			concatName,
  			prefix + FAMILYADJ
  		);

  	while(--specialCount)
  		concatName = Translation.addAdjective(
  			concatName,
  			SPECIALMODADJ
  		);

  	return Translation.addAdjective(
  		concatName,
  		SPECIALMOD
  	);
  };
}

export class CNPlain extends ConstructionNode<[number, number]> {
  readonly type = CNType.Plain;
  child: [number, number];
  polytope: Object | undefined;
	gender: string;

	constructor(child: [number, number]) {
    super();
		this.child = child;
		switch(Translation.language) {
			case "es": this.gender = "male"; break;
			case "de": this.gender = "neuter"; break;
			default: this.gender = "";
		}
	}

  getName(): string {
    return Translation.plainName(this.child[0], this.child[1]);
  }

	setGenders(gender: string): void {
		this.gender = gender;
	}
}

export class CNPolygon extends ConstructionNode<[number, number]> {
  readonly type = CNType.Polygon;
  child: [number, number];
  polytope: Object | undefined;
	gender: string;

	constructor(child: [number, number]) {
    super();
		this.child = child;
		switch(Translation.language) {
			case "es": this.gender = "male"; break;
			case "de": this.gender = "neuter"; break;
			default: this.gender = "";
		}
	}

  getName(): string {
    return Translation.regularPolygonName(this.child[0], this.child[1], {gender: this.gender});
  }

	setGenders(gender: string): void {
		this.gender = gender;
	}
}

export class CNMultiprism extends ConstructionNode<ConstructionNode<any>[]> {
  readonly type = CNType.Multiprism;
  child: ConstructionNode<any>[];
  polytope: Object | undefined;
	gender: string;

	constructor(child: ConstructionNode<any>[]) {
    super();
		this.child = child;
		switch(Translation.language) {
			case "es": this.gender = "male"; break;
			case "de": this.gender = "neuter"; break;
			default: this.gender = "";
		}
	}

  getName(): string {
		this.mergeChildren();
		return ConstructionNode.multiFamily(this.child, "family/prism", "shape/dyad", "family/prism", this.gender);
	}

	setGenders(gender: string): void {
		this.gender = gender;
		for(let i = 0; i < this.child.length; i++)
			this.child[i].setGenders(gender);
	}
}

export class CNMultitegum extends ConstructionNode<ConstructionNode<any>[]> {
  readonly type = CNType.Multitegum;
  child: ConstructionNode<any>[];
  polytope: Object | undefined;
	gender: string;

	constructor(child: ConstructionNode<any>[]) {
    super();
		this.child = child;
		switch(Translation.language) {
			case "es": this.gender = "male"; break;
			case "de": this.gender = "neuter"; break;
			default: this.gender = "";
		}
	}

  getName(): string {
		this.mergeChildren();
		return ConstructionNode.multiFamily(this.child, "family/tegum", "shape/dyad", "family/bipyramid", this.gender);
	}

	setGenders(gender: string): void {
		this.gender = gender;
		for(let i = 0; i < this.child.length; i++)
			this.child[i].setGenders(gender);
	}
}

export class CNMultipyramid extends ConstructionNode<ConstructionNode<any>[]> {
	readonly type = CNType.Multipyramid;
  child: ConstructionNode<any>[];
  polytope: Object | undefined;
	gender: string;

	constructor(child: ConstructionNode<any>[]) {
    super();
		this.child = child;
		switch(Translation.language) {
			case "es":
			case "de": this.gender = "female"; break;
			default: this.gender = "";
		}
	}

  getName(): string {
		this.mergeChildren();
		return ConstructionNode.multiFamily(this.child, "family/pyramid", "shape/point", "family/pyramid", this.gender);
	}

	setGenders(gender: string): void {
		this.gender = gender;
		for(let i = 0; i < this.child.length; i++)
			this.child[i].setGenders(gender);
	}
}

export class CNAntiprism extends ConstructionNode<ConstructionNode<any>> {
	readonly type = CNType.Antiprism;
  child: ConstructionNode<any>;
  polytope: Object | undefined;
	gender: string;

	constructor(child: ConstructionNode<any>) {
    super();
		this.child = child;
		switch(Translation.language) {
			case "es": this.gender = "male"; break;
			case "de": this.gender = "neuter"; break;
			default: this.gender = "";
		}
	}

  getName(): string {
		return ConstructionNode.familyMember(this.child, "family/antiprism", this.gender);
	}

	setGenders(gender: string): void {
		this.gender = gender;
		this.child.setGenders(gender);
	}
}

export class CNPyramid extends ConstructionNode<ConstructionNode<any>> {
	readonly type = CNType.Pyramid;
  child: ConstructionNode<any>;
  polytope: Object | undefined;
	gender: string;

	constructor(child: ConstructionNode<any>) {
    super();
		this.child = child;
		switch(Translation.language) {
			case "es":
			case "de": this.gender = "female"; break;
			default: this.gender = "";
		}
	}

  getName(): string {
		return ConstructionNode.familyMember(this.child, "family/pyramid", this.gender);
	}

	setGenders(gender: string): void {
		this.gender = gender;
		this.child.setGenders(gender);
	}
}

export class CNCupola extends ConstructionNode<ConstructionNode<any>> {
	readonly type = CNType.Cupola;
  child: ConstructionNode<any>;
  polytope: Object | undefined;
	gender: string;

	constructor(child: ConstructionNode<any>) {
    super();
		this.child = child;
		switch(Translation.language) {
			case "es":
			case "de": this.gender = "female"; break;
			default: this.gender = "";
		}
	}

  getName(): string {
		return ConstructionNode.familyMember(this.child, "family/cupola", this.gender);
	}

	setGenders(gender: string): void {
		this.gender = gender;
		this.child.setGenders(gender);
	}
}

export class CNCuploid extends ConstructionNode<ConstructionNode<any>> {
	readonly type = CNType.Cuploid;
  child: ConstructionNode<any>;
  polytope: Object | undefined;
	gender: string;

	constructor(child: ConstructionNode<any>) {
    super();
		this.child = child;
		switch(Translation.language) {
			case "es": this.gender = "male"; break;
			default: this.gender = "";
		}
	}

  getName(): string {
		return ConstructionNode.familyMember(this.child, "family/cuploid", this.gender);
	}

	setGenders(gender: string): void {
		this.gender = gender;
		this.child.setGenders(gender);
	}
}

export class CNCupolaicBlend extends ConstructionNode<ConstructionNode<any>> {
	readonly type = CNType.CupolaicBlend;
  child: ConstructionNode<any>;
  polytope: Object | undefined;
	gender: string;

	constructor(child: ConstructionNode<any>) {
    super();
		this.child = child;
		switch(Translation.language) {
			case "es":
			case "de": this.gender = "female"; break;
			default: this.gender = "";
		}
	}

  getName(): string {
		return ConstructionNode.familyMember(this.child, "family/cupolaicBlend", this.gender);
	}

	setGenders(gender: string): void {
		this.gender = gender;
	}
}

export class CNCodename extends ConstructionNode<string> {
	readonly type = CNType.Codename;
  child: string;
  polytope: Object | undefined;
	gender: string;

	constructor(child: string) {
    super();
		this.child = child;
		this.gender = "";
	}

  getName(): string {
		return Translation.get("shape/" + this.child, {gender: this.gender});
	}

	setGenders(gender: string): void {
		this.gender = gender;
	}
}

export class CNName extends ConstructionNode<string> {
	readonly type = CNType.Codename;
  child: string;
  polytope: Object | undefined;
	gender: string;

	constructor(child: string) {
    super();
		this.child = child;
		this.gender = "";
	}

  getName(): string {
		return this.child;
	}

	setGenders(gender: string): void {
		this.gender = gender;
	}
}

export class CNHypercube extends ConstructionNode<number> {
	readonly type = CNType.Hypercube;
  child: number;
  polytope: Object | undefined;
	gender: string;

	constructor(child: number) {
    super();
		this.child = child;
		this.gender = "";
	}

  getName(): string {
		return Translation.hypercube(this.child);
	}

	setGenders(gender: string): void {
		this.gender = gender;
	}
}

export class CNSimplex extends ConstructionNode<number> {
	readonly type = CNType.Simplex;
  child: number;
  polytope: Object | undefined;
	gender: string;

	constructor(child: number) {
    super();
		this.child = child;
		this.gender = "";
	}

  getName(): string {
		return Translation.simplex(this.child);
	}

	setGenders(gender: string): void {
		this.gender = gender;
	}
}

export class CNCross extends ConstructionNode<number> {
	readonly type = CNType.Cross;
  child: number;
  polytope: Object | undefined;
	gender: string;

	constructor(child: number) {
    super();
		this.child = child;
		this.gender = "";
	}

  getName(): string {
		return Translation.cross(this.child);
	}

	setGenders(gender: string): void {
		this.gender = gender;
	}
}
