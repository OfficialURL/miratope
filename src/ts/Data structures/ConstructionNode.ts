import * as Naming from "../Translation/Naming";
import * as Adjective from "../Translation/Adjective";
import * as Translation from "../Translation/Translation";

import { Gender } from "../Translation/interfaces";
import type { PolytopeB } from "../polytopes/types";

/** An enumeration containing the possible types of [[`ConstructionNode`]]s. */
export enum Type {
  /**
   * The corresponding ConstructionNode has two children `[n, d]`,
   * representing the number of facets `n`
   * and the number of dimensions `d` of the polytope.
   * Its name is generated by [[`plain`]].
   */
  Plain,

  /**
   * The corresponding ConstructionNode has two children `[n, d]`, representing
   * the regular polygon {n/d}.
   * Its name is generated by [[`regularPolygonName`]].
   */
  Polygon,

  /**
   * The corresponding ConstructionNode has an array with the factors of a prism
   * product as children.
   * Its name is generated by [[`multiFamily`]].
   */
  Multiprism,

  /**
   * The corresponding ConstructionNode has an array with the factors of a tegum
   * product as children.
   * Its name is generated by [[`multiFamily`]].
   */
  Multitegum,

  /**
   * The corresponding ConstructionNode has an array with the factors of a
   * pyramid product as children.
   * Its name is generated by [[`multiFamily`]].
   */
  Multipyramid,

  /**
   * The corresponding ConstructionNode has a single child representing the
   * antiprismatic base.
   * Its name is generated by [[`familyMember`]].
   */
  Antiprism,

  /**
   * The corresponding ConstructionNode has a single child representing the
   * pyramidal base.
   * Its name is generated by [[`familyMember`]].
   */
  Pyramid,

  /**
   * The corresponding ConstructionNode has a single child representing the
   * cupoidal base.
   * Its name is generated by [[`familyMember`]].
   */
  Cupola,

  /**
   * The corresponding ConstructionNode has a single child representing the
   * cuploidal base.
   * Its name is generated by [[`familyMember`]].
   */
  Cuploid,

  /**
   * The corresponding ConstructionNode has a single child representing the
   * cupolaic blend base.
   * Its name is generated by [[`familyMember`]].
   */
  CupolaicBlend,

  /**
   * The corresponding ConstructionNode has a polytope's "code name" as a child.
   * Used for polytopes whose names are in loadMessages.js.
   * Can be translated.
   * Its name is generated by [[`Translation.get`]].
   */
  Codename,

  /**
   * The corresponding ConstructionNode has a polytope's name as a child.
   * The default for imported polytopes,
   * or polytopes not built out of anything else whose name is known.
   * Can **not** be translated.
   * Its name is just the ConstructionNode's child itslf.
   */
  Name,

  /**
   * The corresponding ConstructionNode has the dimension of a hypercube as a
   * child.
   * Its name is generated by [[`Naming.hypercube`]].
   */
  Hypercube,

  /**
   * The corresponding ConstructionNode has the dimension of a simplex as a
   * child.
   * Its name is generated by [[`Naming.simplex`]].
   */
  Simplex,

  /**
   * The corresponding ConstructionNode has the dimension of an orthoplex as a
   * child.
   * Its name is generated by [[`Naming.cross`]].
   */
  Cross,
}

export default abstract class ConstructionNode<T> {
  /** The type of ConstructionNode. */
  abstract readonly type: Type;

  /** The "child" of the node, stores information about the construction of a
   * polytope. The exact information it stores depends on the [[`type`]]. */
  abstract child: T;

  abstract polytope: PolytopeB | undefined;
  abstract gender: Gender;

  /** Returns the name of the polytope represented by the `ConstructionNode`.
   */
  abstract getName(): string;

  /** Assigns its own gender to its children, whenever the children are
  ConstructionNodes too. */
  abstract setGenders(gender: Gender): void;

  /**
   * A multiprism of multiprisms is just a larger multiprism,
   * a multitegum of multitegums is just a larger multitegum, etc.
   * This function removes children nodes of the same type
   * and replaces them by their children.
   */
  mergeChildren(): void {
    // If the children are an array.
    if (this.child instanceof Array) {
      const oldLength = this.child.length;

      // For each of the array's members:
      for (let i = 0; i < oldLength; i++) {
        // If the child is of the same type of construction node:
        if (this.child[i].type === this.type) {
          const child = this.child[i].child;

          // The child should always be an array.
          if (!(child instanceof Array)) {
            throw new Error(
              "mergeChildren called despite children not being arrays."
            );
          }

          // Flatten the children array.
          for (let j = 0; j < child.length - 1; j++) {
            this.child.push(child.pop());
          }

          this.child[i] = child.pop();
        }
      }
    } else {
      throw new Error(
        "mergeChildren can only be called in a product ConstructionNode."
      );
    }
  }

  /**
   * Converts a ConstructionNode into the corresponding member of the specified
   * family's name.
   *
   * @param family The code for the family's name.
   * @param gender The grammatical gender of the resulting expression.
   *
   * @example
   * const cube = new Hypercube(3);
   *
   * //Cubic pyramid.
   * console.log(cube.familyMember("family/pyramid"));
   */
  familyMember(family: string): string {
    return Adjective.add(
      Adjective.convert(this.getName(), this.gender),
      Translation.get(family)
    );
  }

  /**
   * Converts a set of ConstructionNodes into their
   * prism product/tegum product/pyramid product's name.
   *
   * @param nodes The array of nodes to convert.
   * @param family The prodct used (i.e. `"prism"`, `"tegum"` or `"pyramid"`).
   * @param specialFactor An element such that, when it appears in the product,
   * is considered differently.
   * @param specialFactorModify Specifies what `specialFactor` becomes into
   * within the product.
   * @returns The resulting name.
   *
   * @example
   * const triangle = new Polygon([3, 1]);
   * const pentagram = new Polygon([5, 2]);
   *
   * //Triangular-pentagrammic duoprism.
   * console.log(ConstructionNode.multiFamily(
   *     [triangle, pentagram],
   *     "family/multiprism",
   *     "shape/dyad",
   *     "shape/prism"
   * ));
   */
  static multiFamily(
    nodes: ConstructionNode<unknown>[],
    family: string,
    specialFactor: string,
    specialFactorModify: string,
    gender: Gender
  ): string {
    const names: string[] = [];
    const FAMILY = Translation.get(family);
    const FAMILYADJ = Adjective.convert(FAMILY, gender);
    const SPECIAL = Translation.get(specialFactor);
    const SPECIALMOD = Translation.get(specialFactorModify);
    const SPECIALMODADJ = Adjective.convert(SPECIALMOD, gender);
    let specialCount = 0;
    let tempName: string;
    let concatName: string;
    let allNameSame = true;

    // Counts special factors.
    for (let i = 0; i < nodes.length; i++) {
      tempName = nodes[i].getName();
      if (tempName === SPECIAL) specialCount++;
      else names.push(tempName);
    }

    // The prefix before [family], e.g. *duo*[family], *trio*[family], ...
    let prefix: string;
    switch (names.length) {
      // All special factors.
      case 0:
        names.push(SPECIAL);
        specialCount--;
        prefix = "";
        break;
      case 1:
        prefix = "";
        break;
      case 2:
        prefix = "duo";
        break;
      case 3:
        prefix = "trio";
        break;
      default:
        prefix = Naming.greekPrefix(names.length);
        break;
    }

    // names cannot be empty.
    tempName = names.pop() as string;
    concatName = Adjective.convert(tempName, gender);

    while (names.length > 0) {
      concatName += "-" + Adjective.convert(names[names.length - 1], gender);
      if (names.pop() !== tempName) allNameSame = false;
    }

    if (!specialCount) {
      // X multi[family]
      if (allNameSame) {
        return Adjective.add(
          Adjective.convert(tempName, gender),
          prefix + FAMILY
        );
      }

      // X-Y-Z multi[family]
      return Adjective.add(concatName, prefix + FAMILY);
    }

    // Same as before, but adds as many ...[family-adj] [family]	as needed at the
    // end.
    if (allNameSame) concatName = Adjective.convert(tempName, gender);

    // We aren't calling a single polytope X an "X mono[family]", are we?
    if (prefix) concatName = Adjective.add(concatName, prefix + FAMILYADJ);

    while (--specialCount) {
      concatName = Adjective.add(concatName, SPECIALMODADJ);
    }

    return Adjective.add(concatName, SPECIALMOD);
  }
}

/**
 * A ConstructionNode of [[`Plain`]] type.
 *
 * @category ConstructionNode Types
 */
export class Plain extends ConstructionNode<[number, number]> {
  readonly type = Type.Plain;
  child: [number, number];
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: [number, number]) {
    super();
    this.child = child;
    switch (Translation.language) {
      case "es":
        this.gender = Gender.male;
        break;
      case "de":
        this.gender = Gender.neuter;
        break;
      default:
        this.gender = Gender.male;
    }
  }

  getName(): string {
    return Naming.plain(this.child[0], this.child[1]);
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
  }
}

/**
 * A ConstructionNode of [[`Polygon`]] type.
 *
 * @category ConstructionNode Types
 */
export class Polygon extends ConstructionNode<[number, number]> {
  readonly type = Type.Polygon;
  child: [number, number];
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: [number, number]) {
    super();
    this.child = child;
    switch (Translation.language) {
      case "es":
        this.gender = Gender.male;
        break;
      case "de":
        this.gender = Gender.neuter;
        break;
      default:
        this.gender = Gender.male;
    }
  }

  getName(): string {
    return Naming.regularPolygon(this.child[0], this.child[1], {
      gender: this.gender,
    });
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
  }
}

/**
 * A ConstructionNode of [[`Multiprism`]] type.
 *
 * @category ConstructionNode Types
 */
export class Multiprism extends ConstructionNode<ConstructionNode<unknown>[]> {
  readonly type = Type.Multiprism;
  child: ConstructionNode<unknown>[];
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: ConstructionNode<unknown>[]) {
    super();
    this.child = child;
    switch (Translation.language) {
      case "es":
        this.gender = Gender.male;
        break;
      case "de":
        this.gender = Gender.neuter;
        break;
      default:
        this.gender = Gender.male;
    }
  }

  getName(): string {
    this.mergeChildren();
    return ConstructionNode.multiFamily(
      this.child,
      "family/prism",
      "shape/dyad",
      "family/prism",
      this.gender
    );
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
    for (let i = 0; i < this.child.length; i++) {
      this.child[i].setGenders(gender);
    }
  }
}

/**
 * A ConstructionNode of [[`Multitegum`]] type.
 *
 * @category ConstructionNode Types
 */
export class Multitegum extends ConstructionNode<ConstructionNode<unknown>[]> {
  readonly type = Type.Multitegum;
  child: ConstructionNode<unknown>[];
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: ConstructionNode<unknown>[]) {
    super();
    this.child = child;
    switch (Translation.language) {
      case "es":
        this.gender = Gender.male;
        break;
      case "de":
        this.gender = Gender.neuter;
        break;
      default:
        this.gender = Gender.male;
    }
  }

  getName(): string {
    this.mergeChildren();
    return ConstructionNode.multiFamily(
      this.child,
      "family/tegum",
      "shape/dyad",
      "family/bipyramid",
      this.gender
    );
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
    for (let i = 0; i < this.child.length; i++) {
      this.child[i].setGenders(gender);
    }
  }
}

/**
 * A ConstructionNode of [[`Multipyramid`]] type.
 *
 * @category ConstructionNode Types
 */
export class Multipyramid extends ConstructionNode<
  ConstructionNode<unknown>[]
> {
  readonly type = Type.Multipyramid;
  child: ConstructionNode<unknown>[];
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: ConstructionNode<unknown>[]) {
    super();
    this.child = child;
    switch (Translation.language) {
      case "es":
      case "de":
        this.gender = Gender.female;
        break;
      default:
        this.gender = Gender.male;
    }
  }

  getName(): string {
    this.mergeChildren();
    return ConstructionNode.multiFamily(
      this.child,
      "family/pyramid",
      "shape/Point",
      "family/pyramid",
      this.gender
    );
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
    for (let i = 0; i < this.child.length; i++) {
      this.child[i].setGenders(gender);
    }
  }
}

/**
 * A ConstructionNode of [[`Antiprism`]] type.
 *
 * @category ConstructionNode Types
 */
export class Antiprism extends ConstructionNode<ConstructionNode<unknown>> {
  readonly type = Type.Antiprism;
  child: ConstructionNode<unknown>;
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: ConstructionNode<unknown>) {
    super();
    this.child = child;
    switch (Translation.language) {
      case "es":
        this.gender = Gender.male;
        break;
      case "de":
        this.gender = Gender.neuter;
        break;
      default:
        this.gender = Gender.male;
    }
  }

  getName(): string {
    return this.child.familyMember("family/antiprism");
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
    this.child.setGenders(gender);
  }
}

/**
 * A ConstructionNode of [[`Pyramid`]] type.
 *
 * @category ConstructionNode Types
 */
export class Pyramid extends ConstructionNode<ConstructionNode<unknown>> {
  readonly type = Type.Pyramid;
  child: ConstructionNode<unknown>;
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: ConstructionNode<unknown>) {
    super();
    this.child = child;
    switch (Translation.language) {
      case "es":
      case "de":
        this.gender = Gender.female;
        break;
      default:
        this.gender = Gender.male;
    }
  }

  getName(): string {
    return this.child.familyMember("family/pyramid");
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
    this.child.setGenders(gender);
  }
}

/**
 * A ConstructionNode of [[`Cupola`]] type.
 *
 * @category ConstructionNode Types
 */
export class Cupola extends ConstructionNode<ConstructionNode<unknown>> {
  readonly type = Type.Cupola;
  child: ConstructionNode<unknown>;
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: ConstructionNode<unknown>) {
    super();
    this.child = child;
    switch (Translation.language) {
      case "es":
      case "de":
        this.gender = Gender.female;
        break;
      default:
        this.gender = Gender.male;
    }
  }

  getName(): string {
    return this.child.familyMember("family/cupola");
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
    this.child.setGenders(gender);
  }
}

/**
 * A ConstructionNode of [[`Cuploid`]] type.
 *
 * @category ConstructionNode Types
 */
export class Cuploid extends ConstructionNode<ConstructionNode<unknown>> {
  readonly type = Type.Cuploid;
  child: ConstructionNode<unknown>;
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: ConstructionNode<unknown>) {
    super();
    this.child = child;
    switch (Translation.language) {
      case "es":
        this.gender = Gender.male;
        break;
      default:
        this.gender = Gender.male;
    }
  }

  getName(): string {
    return this.child.familyMember("family/cuploid");
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
    this.child.setGenders(gender);
  }
}

/**
 * A ConstructionNode of [[`CupolaicBlend`]] type.
 *
 * @category ConstructionNode Types
 */
export class CupolaicBlend extends ConstructionNode<ConstructionNode<unknown>> {
  readonly type = Type.CupolaicBlend;
  child: ConstructionNode<unknown>;
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: ConstructionNode<unknown>) {
    super();
    this.child = child;
    switch (Translation.language) {
      case "es":
      case "de":
        this.gender = Gender.female;
        break;
      default:
        this.gender = Gender.male;
    }
  }

  getName(): string {
    return this.child.familyMember("family/cupolaicBlend");
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
  }
}

/**
 * A ConstructionNode of [[`Codename`]] type.
 *
 * @category ConstructionNode Types
 */
export class Codename extends ConstructionNode<string> {
  readonly type = Type.Codename;
  child: string;
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: string) {
    super();
    this.child = child;
    this.gender = Gender.male;
  }

  getName(): string {
    return Translation.get("shape/" + this.child, { gender: this.gender });
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
  }
}

/**
 * A ConstructionNode of [[`Name`]] type.
 *
 * @category ConstructionNode Types
 */
export class Name extends ConstructionNode<string> {
  readonly type = Type.Codename;
  child: string;
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: string) {
    super();
    this.child = child;
    this.gender = Gender.male;
  }

  getName(): string {
    return this.child;
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
  }
}

/**
 * A ConstructionNode of [[`Hypercube`]] type.
 *
 * @category ConstructionNode Types
 */
export class Hypercube extends ConstructionNode<number> {
  readonly type = Type.Hypercube;
  child: number;
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: number) {
    super();
    this.child = child;
    this.gender = Gender.male;
  }

  getName(): string {
    return Naming.hypercube(this.child);
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
  }
}

/**
 * A ConstructionNode of [[`Simplex`]] type.
 *
 * @category ConstructionNode Types
 */
export class Simplex extends ConstructionNode<number> {
  readonly type = Type.Simplex;
  child: number;
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: number) {
    super();
    this.child = child;
    this.gender = Gender.male;
  }

  getName(): string {
    return Naming.simplex(this.child);
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
  }
}

/**
 * A ConstructionNode of [[`Cross`]] type.
 *
 * @category ConstructionNode Types
 */
export class Cross extends ConstructionNode<number> {
  readonly type = Type.Cross;
  child: number;
  polytope: PolytopeB | undefined;
  gender: Gender;

  constructor(child: number) {
    super();
    this.child = child;
    this.gender = Gender.male;
  }

  getName(): string {
    return Naming.cross(this.child);
  }

  setGenders(gender: Gender): void {
    this.gender = gender;
  }
}
